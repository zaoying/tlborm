<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js ayu">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>片段分类符 - The Little Book of Rust Macros</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="../../favicon.svg">
        
        
        <link rel="shortcut icon" href="../../favicon.png">
        
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        
        <link rel="stylesheet" href="../../css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="../../fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="../../res/rust-syntax-bg-highlight.css">
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('ayu')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../../introduction.html">简介</a></li><li class="chapter-item expanded "><a href="../../macros.html"><strong aria-hidden="true">1.</strong> 方法论</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../macros/syntax.html"><strong aria-hidden="true">1.1.</strong> 语法拓展</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../macros/syntax/source-analysys.html"><strong aria-hidden="true">1.1.1.</strong> 源代码分析</a></li><li class="chapter-item expanded "><a href="../../macros/syntax/ast.html"><strong aria-hidden="true">1.1.2.</strong> AST 中的宏</a></li><li class="chapter-item expanded "><a href="../../macros/syntax/expansion.html"><strong aria-hidden="true">1.1.3.</strong> 宏展开</a></li></ol></li><li class="chapter-item expanded "><a href="../../macros/macro_rules.html"><strong aria-hidden="true">1.2.</strong> macro_rules!</a></li><li class="chapter-item expanded "><a href="../../macros/minutiae.html"><strong aria-hidden="true">1.3.</strong> 细节</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../macros/minutiae/fragment-specifiers.html" class="active"><strong aria-hidden="true">1.3.1.</strong> 片段分类符</a></li><li class="chapter-item expanded "><a href="../../macros/minutiae/metavar-and-expansion.html"><strong aria-hidden="true">1.3.2.</strong> 元变量与宏展开</a></li><li class="chapter-item expanded "><a href="../../macros/minutiae/hygiene.html"><strong aria-hidden="true">1.3.3.</strong> 宏是“卫生的”</a></li><li class="chapter-item expanded "><a href="../../macros/minutiae/identifiers.html"><strong aria-hidden="true">1.3.4.</strong> 非标识符的“标识符”</a></li><li class="chapter-item expanded "><a href="../../macros/minutiae/debugging.html"><strong aria-hidden="true">1.3.5.</strong> 调试</a></li><li class="chapter-item expanded "><a href="../../macros/minutiae/scoping.html"><strong aria-hidden="true">1.3.6.</strong> 作用域</a></li><li class="chapter-item expanded "><a href="../../macros/minutiae/import-export.html"><strong aria-hidden="true">1.3.7.</strong> 导入与导出宏</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../../macros-practical.html"><strong aria-hidden="true">2.</strong> 实战</a></li><li class="chapter-item expanded "><a href="../../patterns.html"><strong aria-hidden="true">3.</strong> 模式</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../patterns/callbacks.html"><strong aria-hidden="true">3.1.</strong> 回调</a></li><li class="chapter-item expanded "><a href="../../patterns/tt-muncher.html"><strong aria-hidden="true">3.2.</strong> tt 递增</a></li><li class="chapter-item expanded "><a href="../../patterns/internal-rules.html"><strong aria-hidden="true">3.3.</strong> 内部规则</a></li><li class="chapter-item expanded "><a href="../../patterns/push-down-acc.html"><strong aria-hidden="true">3.4.</strong> 向下堆积</a></li><li class="chapter-item expanded "><a href="../../patterns/repetition-replacement.html"><strong aria-hidden="true">3.5.</strong> 反复替换</a></li><li class="chapter-item expanded "><a href="../../patterns/tt-bundling.html"><strong aria-hidden="true">3.6.</strong> tt 捆绑</a></li></ol></li><li class="chapter-item expanded "><a href="../../building-blocks.html"><strong aria-hidden="true">4.</strong> 构建元素</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../building-blocks/ast-coercion.html"><strong aria-hidden="true">4.1.</strong> AST 强制转换</a></li><li class="chapter-item expanded "><a href="../../building-blocks/counting.html"><strong aria-hidden="true">4.2.</strong> 计数</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../building-blocks/abacus-counting.html"><strong aria-hidden="true">4.2.1.</strong> 算盘计数</a></li></ol></li><li class="chapter-item expanded "><a href="../../building-blocks/parsing.html"><strong aria-hidden="true">4.3.</strong> 解析</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu (default)</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">The Little Book of Rust Macros</h1>

                    <div class="right-buttons">
                        
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/veykril/tlborm/" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                        

                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="fragment-specifiers"><a class="header" href="#fragment-specifiers">Fragment Specifiers</a></h1>
<p>As shown in the [<code>macro_rules</code>] chapter, Rust, as of 1.46, has 13 fragment specifiers. This section
will go a bit more into detail for some of them and tries to always show a few examples of what a
matcher can match with.</p>
<blockquote>
<p>Note that capturing with anything but the <code>ident</code>, <code>lifetime</code> and <code>tt</code> fragments will render the
captured AST opaque, making it impossible to further inspect it in future macro invocations.</p>
</blockquote>
<ul>
<li><a href="#item"><code>item</code></a></li>
<li><a href="#block"><code>block</code></a></li>
<li><a href="#stmt"><code>stmt</code></a></li>
<li><a href="#pat"><code>pat</code></a></li>
<li><a href="#expr"><code>expr</code></a></li>
<li><a href="#ty"><code>ty</code></a></li>
<li><a href="#ident"><code>ident</code></a></li>
<li><a href="#path"><code>path</code></a></li>
<li><a href="#tt"><code>tt</code></a></li>
<li><a href="#meta"><code>meta</code></a></li>
<li><a href="#lifetime"><code>lifetime</code></a></li>
<li><a href="#vis"><code>vis</code></a></li>
<li><a href="#literal"><code>literal</code></a></li>
</ul>
<h2 id="item"><a class="header" href="#item"><code>item</code></a></h2>
<p>The <code>item</code> fragment simply matches any of Rust's
<a href="https://doc.rust-lang.org/reference/items.html">item</a> <em>definitions</em>, not identifiers that refer to
items. Item examples:</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! items {
    ($($item:item)*) =&gt; ();
}

items! {
    struct Foo;
    enum Bar {
        Baz
    }
    impl Foo {}
    /*...*/
}
<span class="boring">fn main() {}
</span></code></pre></pre>
<h2 id="block"><a class="header" href="#block"><code>block</code></a></h2>
<p>The <code>block</code> fragment solely matches a <a href="https://doc.rust-lang.org/reference/expressions/block-expr.html">block expression</a>,
which consists of an opening <code>{</code> brace, followed by any amount of statements and finally followed
by a closing <code>}</code> brace.</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! blocks {
    ($($block:block)*) =&gt; ();
}

blocks! {
    {}
    {
        let zig;
    }
    { 2 }
}
<span class="boring">fn main() {}
</span></code></pre></pre>
<h2 id="stmt"><a class="header" href="#stmt"><code>stmt</code></a></h2>
<p>The <code>statement</code> fragment solely matches a <a href="https://doc.rust-lang.org/reference/statements.html">statement</a>
without its trailing semicolon, unless its an item statement that requires one. What would be an
item statement that requires one? A Unit-Struct would be a simple one, as defining one requires a
trailing semicolon. </p>
<p>Let's use a simple example to show exactly what is meant with this. We use a macro that merely emits
what it captures:</p>
<pre><code class="language-rust ignore">macro_rules! statements {
    ($($stmt:stmt)*) =&gt; ($($stmt)*);
}

fn main() {
    statements! {
        struct Foo;
        fn foo() {}
        let zig = 3
        let zig = 3;
        3
        3;
        if true {} else {}
        {}
    }
}

</code></pre>
<p>Expanding this, via the <a href="https://play.rust-lang.org/">playground</a> for example<sup class="footnote-reference"><a href="#debugging">1</a></sup>, gives us roughly the
following:</p>
<pre><code class="language-rust ignore">/* snip */

fn main() {
    struct Foo;
    fn foo() { }
    let zig = 3;
    let zig = 3;
    ;
    3;
    3;
    ;
    if true { } else { }
    { }
}
</code></pre>
<p>From this we can tell a few things:</p>
<p>The first you should be able to see immediately is that while the <code>stmt</code> fragment doesn't capture
trailing semicolons, it still emits them when required, even if the statement is already followed by
one. The simple reason for that is that semicolons on their own are already valid statements. So we
are actually invoking our macro here with not 8 statements, but 11!</p>
<p>Another thing you should be able to notice here is that the trailing semicolon of the <code>struct Foo;</code>
item statement is being matched, otherwise we would've seen an extra one like in the other cases.
This makes sense as we already said, that for item statements that require one, the trailing
semicolon will be matched with.</p>
<p>A last observation is that expressions get emitted back with a trailing semicolon, unless the
expression solely consists of only a block expression or control flow expression.</p>
<p>The fine details of what was just mentioned here can be looked up in the
<a href="https://doc.rust-lang.org/reference/statements.html">reference</a>.</p>
<div class="footnote-definition" id="debugging"><sup class="footnote-definition-label">1</sup>
<p>See the <a href="./debugging.html">debugging chapter</a> for tips on how to do this.</p>
</div>
<h2 id="pat"><a class="header" href="#pat"><code>pat</code></a></h2>
<p>The <code>pat</code> fragment matches any kind of <a href="https://doc.rust-lang.org/reference/patterns.html">pattern</a>.</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! patterns {
    ($($pat:pat)*) =&gt; ();
}

patterns! {
    &quot;literal&quot;
    _
    0..5
    ref mut PatternsAreNice
}
<span class="boring">fn main() {}
</span></code></pre></pre>
<h2 id="expr"><a class="header" href="#expr"><code>expr</code></a></h2>
<p>The <code>expr</code> fragment matches any kind of <a href="https://doc.rust-lang.org/reference/expressions.html">expression</a>
(Rust has a lot of them, given it <em>is</em> an expression orientated language).</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! expressions {
    ($($expr:expr)*) =&gt; ();
}

expressions! {
    &quot;literal&quot;
    funcall()
    future.await
    break 'foo bar
}
<span class="boring">fn main() {}
</span></code></pre></pre>
<h2 id="ty"><a class="header" href="#ty"><code>ty</code></a></h2>
<p>The <code>ty</code> fragment matches any kind of <a href="https://doc.rust-lang.org/reference/types.html#type-expressions">type expression</a>.
A type expression is the syntax with which one refers to a type in the language.</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! types {
    ($($type:ty)*) =&gt; ();
}

types! {
    foo::bar
    bool
    [u8]
}
<span class="boring">fn main() {}
</span></code></pre></pre>
<h2 id="ident"><a class="header" href="#ident"><code>ident</code></a></h2>
<p>The <code>ident</code> fragment matches an <a href="https://doc.rust-lang.org/reference/identifiers.html">identifier</a>
or <em>keyword</em>.</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! idents {
    ($($ident:ident)*) =&gt; ();
}

idents! {
    // _ &lt;- This is not an ident, it is a pattern
    foo
    async
    O_________O
    _____O_____
}
<span class="boring">fn main() {}
</span></code></pre></pre>
<h2 id="path"><a class="header" href="#path"><code>path</code></a></h2>
<p>The <code>path</code> fragment matches a so called <a href="https://doc.rust-lang.org/reference/paths.html#paths-in-types">TypePath</a>
style path.</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! paths {
    ($($path:path)*) =&gt; ();
}

paths! {
    ASimplePath
    ::A::B::C::D
    G::&lt;eneri&gt;::C
}
<span class="boring">fn main() {}
</span></code></pre></pre>
<h2 id="tt"><a class="header" href="#tt"><code>tt</code></a></h2>
<p>The <code>tt</code> fragment matches a TokenTree. If you need a refresher on what exactly a TokenTree was you
may want to revisit the <a href="../syntax/source-analysys.html#token-trees">TokenTree chapter</a> of this
book. The <code>tt</code> fragment is one of the most powerful fragments, as it can match nearly anything while
still allowing you to inspect the contents of it at a later state in the macro.</p>
<h2 id="meta"><a class="header" href="#meta"><code>meta</code></a></h2>
<p>The <code>meta</code> fragment matches an <a href="https://doc.rust-lang.org/reference/attributes.html">attribute</a>, to
be more precise, the contents of an attribute. You will usually see this fragment being used in a
matcher like <code>#[$meta:meta]</code> or <code>#![$meta:meta]</code>.</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! metas {
    ($($meta:meta)*) =&gt; ();
}

metas! {
    ASimplePath
    super::man
    path = &quot;home&quot;
    foo(bar)
}
<span class="boring">fn main() {}
</span></code></pre></pre>
<blockquote>
<p>A neat thing about doc comments: They are actually attributes in the form of <code>#[doc=&quot;…&quot;]</code> where
the <code>...</code> is the actual comment string, meaning you can act on doc comments in macros!</p>
</blockquote>
<h2 id="lifetime"><a class="header" href="#lifetime"><code>lifetime</code></a></h2>
<p>The <code>lifetime</code> fragment matches a <a href="https://doc.rust-lang.org/reference/tokens.html#lifetimes-and-loop-labels">lifetime or label</a>.
It's quite similar to <a href="#ident"><code>ident</code></a> but with a prepended <code>'</code>.</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! lifetimes {
    ($($lifetime:lifetime)*) =&gt; ();
}

lifetimes! {
    'static
    'shiv
    '_
}
<span class="boring">fn main() {}
</span></code></pre></pre>
<h2 id="vis"><a class="header" href="#vis"><code>vis</code></a></h2>
<p>The <code>vis</code> fragment matches a <em>possibly empty</em> <a href="https://doc.rust-lang.org/reference/visibility-and-privacy.html">Visibility qualifier</a>.
Emphasis lies on the <em>possibly empty</em> part. You can think of this fragment having an implicit <code>?</code>
repetition to it, meaning you don't, and in fact cannot, wrap it in a direct repetition.</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! visibilities {
    //         ∨~~Note this comma, since we cannot repeat a `vis` fragment on its own 
    ($($vis:vis,)*) =&gt; ();
}

visibilities! {
    ,
    pub,
    pub(crate),
    pub(in super),
    pub(in some_path),
}
<span class="boring">fn main() {}
</span></code></pre></pre>
<h2 id="literal"><a class="header" href="#literal"><code>literal</code></a></h2>
<p>The <code>literal</code> fragment matches any <a href="https://doc.rust-lang.org/reference/expressions/literal-expr.html">literal expression</a>.</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! literals {
    ($($literal:literal)*) =&gt; ();
}

literals! {
    -1
    &quot;hello world&quot;
    2.3
    b'b'
    true
}
<span class="boring">fn main() {}
</span></code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../../macros/minutiae.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../../macros/minutiae/metavar-and-expansion.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="../../macros/minutiae.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="../../macros/minutiae/metavar-and-expansion.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="../../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
