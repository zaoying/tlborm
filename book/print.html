<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js ayu">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Little Book of Rust Macros ï¼ˆRust å®ä¹‹ä¹¦ï¼‰</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="res/rust-syntax-bg-highlight.css">
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('ayu')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><a href="introduction.html">ç®€ä»‹</a></li><li class="chapter-item "><a href="macros.html"><strong aria-hidden="true">1.</strong> æ–¹æ³•è®º</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="macros/syntax.html"><strong aria-hidden="true">1.1.</strong> è¯­æ³•æ‹“å±•</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="macros/syntax/source-analysys.html"><strong aria-hidden="true">1.1.1.</strong> æºä»£ç åˆ†æ</a></li><li class="chapter-item "><a href="macros/syntax/ast.html"><strong aria-hidden="true">1.1.2.</strong> AST ä¸­çš„å®</a></li><li class="chapter-item "><a href="macros/syntax/expansion.html"><strong aria-hidden="true">1.1.3.</strong> å®å±•å¼€</a></li></ol></li><li class="chapter-item "><a href="macros/macro_rules.html"><strong aria-hidden="true">1.2.</strong> macro_rules!</a></li><li class="chapter-item "><a href="macros/minutiae.html"><strong aria-hidden="true">1.3.</strong> ç»†èŠ‚</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="macros/minutiae/fragment-specifiers.html"><strong aria-hidden="true">1.3.1.</strong> ç‰‡æ®µåˆ†ç±»ç¬¦</a></li><li class="chapter-item "><a href="macros/minutiae/metavar-and-expansion.html"><strong aria-hidden="true">1.3.2.</strong> å…ƒå˜é‡ä¸å®å±•å¼€</a></li><li class="chapter-item "><a href="macros/minutiae/hygiene.html"><strong aria-hidden="true">1.3.3.</strong> å®æ˜¯â€œå«ç”Ÿçš„â€</a></li><li class="chapter-item "><a href="macros/minutiae/identifiers.html"><strong aria-hidden="true">1.3.4.</strong> éæ ‡è¯†ç¬¦çš„â€œæ ‡è¯†ç¬¦â€</a></li><li class="chapter-item "><a href="macros/minutiae/debugging.html"><strong aria-hidden="true">1.3.5.</strong> è°ƒè¯•</a></li><li class="chapter-item "><a href="macros/minutiae/scoping.html"><strong aria-hidden="true">1.3.6.</strong> ä½œç”¨åŸŸ</a></li><li class="chapter-item "><a href="macros/minutiae/import-export.html"><strong aria-hidden="true">1.3.7.</strong> å¯¼å…¥ä¸å¯¼å‡ºå®</a></li></ol></li></ol></li><li class="chapter-item "><a href="macros-practical.html"><strong aria-hidden="true">2.</strong> å®æˆ˜</a></li><li class="chapter-item "><a href="patterns.html"><strong aria-hidden="true">3.</strong> æ¨¡å¼</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="patterns/callbacks.html"><strong aria-hidden="true">3.1.</strong> å›è°ƒ</a></li><li class="chapter-item "><a href="patterns/tt-muncher.html"><strong aria-hidden="true">3.2.</strong> tt é€’å¢</a></li><li class="chapter-item "><a href="patterns/internal-rules.html"><strong aria-hidden="true">3.3.</strong> å†…éƒ¨è§„åˆ™</a></li><li class="chapter-item "><a href="patterns/push-down-acc.html"><strong aria-hidden="true">3.4.</strong> å‘ä¸‹å †ç§¯</a></li><li class="chapter-item "><a href="patterns/repetition-replacement.html"><strong aria-hidden="true">3.5.</strong> åå¤æ›¿æ¢</a></li><li class="chapter-item "><a href="patterns/tt-bundling.html"><strong aria-hidden="true">3.6.</strong> tt æ†ç»‘</a></li></ol></li><li class="chapter-item "><a href="building-blocks.html"><strong aria-hidden="true">4.</strong> æ„å»ºå…ƒç´ </a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="building-blocks/ast-coercion.html"><strong aria-hidden="true">4.1.</strong> AST å¼ºåˆ¶è½¬æ¢</a></li><li class="chapter-item "><a href="building-blocks/counting.html"><strong aria-hidden="true">4.2.</strong> è®¡æ•°</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="building-blocks/abacus-counting.html"><strong aria-hidden="true">4.2.1.</strong> ç®—ç›˜è®¡æ•°</a></li></ol></li><li class="chapter-item "><a href="building-blocks/parsing.html"><strong aria-hidden="true">4.3.</strong> è§£æ</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu (default)</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">The Little Book of Rust Macros ï¼ˆRust å®ä¹‹ä¹¦ï¼‰</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/zjp-CN/tlborm" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                        

                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="the-little-book-of-rust-macros-rust-å®ä¹‹ä¹¦"><a class="header" href="#the-little-book-of-rust-macros-rust-å®ä¹‹ä¹¦">The Little Book of Rust Macros ï¼ˆRust å®ä¹‹ä¹¦ï¼‰</a></h1>
<blockquote>
<p>æ³¨æ„ï¼šè¿™æ˜¯å¯¹ <a href="https://github.com/DanielKeep/tlborm">Daniel Keep æ’°å†™çš„ä¹¦</a> çš„ç»­å†™ï¼Œ
è‡ª 2016 å¹´åˆå¤ä»¥æ¥ï¼Œé‚£æœ¬ä¹¦å°±ä¸€ç›´æ²¡å†æ›´æ–°ã€‚</p>
</blockquote>
<p>æœ¬ä¹¦ä½¿ç”¨ <a href="https://github.com/rust-lang/mdBook">mdBook</a> å·¥å…·ç”Ÿæˆã€‚
ä½ å¯ä»¥æµè§ˆæœ¬ä¹¦çš„ <a href="https://veykril.github.io/tlborm/">è‹±æ–‡ç‰ˆæœ¬</a>ï¼Œ
å’Œ github <a href="https://github.com/veykril/tlborm">ä»“åº“</a>ã€‚</p>
<p>ï¼ˆè¯‘è€…æ³¨ï¼šç»­å†™çš„ç‰ˆæœ¬ç”± <a href="https://github.com/Veykril">Veykril</a> æ’°ç¨¿ã€‚
ä½ ä¹Ÿå¯ä»¥æµè§ˆ <a href="https://zjp-cn.github.io/tlborm/book">ä¸­æ–‡ç¿»è¯‘ç‰ˆ</a>ã€ <a href="https://github.com/zjp-CN/tlborm">ç¿»è¯‘ä»“åº“</a> ï¼‰</p>
<p>è¿™æœ¬ä¹¦å°è¯•æç‚¼å‡º Rust ç¤¾åŒºå¯¹ Rust å®çš„å…±è¯†ï¼Œå‡†ç¡®åœ°è¯´ï¼Œæ˜¯ <em>é€šè¿‡ä¾‹å­</em> æ¥è®²è¿°å®ã€‚å› æ­¤ï¼Œæ¬¢è¿ PR è¡¥å……å’Œæ issueã€‚</p>
<p>åœ¨æˆ‘å­¦ä¹  Rust çš„æ—¶å€™ï¼Œ<em>Little Book of Rust Macros</em> <a href="https://github.com/DanielKeep/tlborm">åŸä½œ</a> <strong>é€šè¿‡ä¾‹å­</strong> çš„æ–¹å¼éå¸¸ç»™åŠ›åœ°å¸®åŠ©è¿‡æˆ‘ç†è§£å®ã€‚
å¾ˆé—æ†¾çš„æ˜¯ï¼ŒRust è¯­è¨€ä¸å®ç³»ç»ŸæŒç»­æ”¹è¿›æ—¶ï¼ŒåŸä½œè€…ä¸å†æ›´æ–°ä¹¦ç±ã€‚
è¿™ä¹Ÿæ˜¯æˆ‘æƒ³é‡æ–°ç»§ç»­è¿™æœ¬ä¹¦çš„åŸå› ï¼Œè®©ä¹¦ä¸å½“å‰çš„ Rust åŒæ­¥ï¼Œä»¥å¸®åŠ©æ–°çš„ Rust å­¦ä¹ è€…ç†è§£å®â€”â€”è¿™ä¸ªè®©å¾ˆå¤šäººå›°æƒ‘çš„éƒ¨åˆ†ã€‚</p>
<blockquote>
<p>è¿™æœ¬ä¹¦è®¤ä¸ºä½ åº”è¯¥å¯¹ Rust æœ‰åŸºæœ¬çš„äº†è§£ï¼Œå®ƒä¸ä¼šè§£é‡Š Rust è¯­è¨€ç‰¹æ€§æˆ–è€…ä¸å®æœ‰å…³çš„ç»“æ„ä½“ã€‚
å¦‚æœä½ ä¹‹å‰å¯¹å®æ²¡æœ‰äº†è§£ï¼Œé‚£ä¹ˆä½ å¿…é¡»è‡³å°‘é˜…è¯»å’Œç†è§£äº† <a href="https://doc.rust-lang.org/stable/book/">Rust Book</a> çš„å‰ä¸ƒç« â€”â€”å»ºè®®é˜…è¯»å®Œé‚£æœ¬ä¹¦å¤§éƒ¨åˆ†å†…å®¹ã€‚</p>
</blockquote>
<h2 id="æ„Ÿè°¢"><a class="header" href="#æ„Ÿè°¢">æ„Ÿè°¢</a></h2>
<p>æ„Ÿè°¢ Daniel Keep æœ€åˆå†™ä¸‹è¿™æœ¬ä¹¦ã€‚æ„Ÿè°¢å¯¹åŸä¹¦æå‡ºå»ºè®®å’Œæ›´æ­£çš„è¯»è€…ï¼šIcyFoxyã€ Rymã€ TheMicroWormã€ Yurumeã€ akavelã€ cmrã€ eddybã€ ogham å’Œ snake_caseã€‚</p>
<h2 id="ç‰ˆæƒå£°æ˜"><a class="header" href="#ç‰ˆæƒå£°æ˜">ç‰ˆæƒå£°æ˜</a></h2>
<p>è¿™æœ¬ä¹¦æ²¿è¢­äº†åŸä½œçš„ç‰ˆæƒå£°æ˜ï¼Œå› æ­¤å…·æœ‰ <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> å’Œ <a href="http://opensource.org/licenses/MIT">MIT license</a> çš„åŒé‡è®¸å¯ã€‚</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="æ–¹æ³•è®º"><a class="header" href="#æ–¹æ³•è®º">æ–¹æ³•è®º</a></h1>
<p>æœ¬ç« å°†ä»‹ç» Rust çš„å£°æ˜å®ç³»ç»Ÿï¼š <a href="https://doc.rust-lang.org/reference/macros-by-example.html"><code>macro_rules!</code></a>ï¼Œè¿™åœ¨ <a href="https://doc.rust-lang.org/reference/macros-by-example.html">Reference: Macro-By-Example</a> ä¸€èŠ‚ä¸­ä»‹ç»è¿‡ã€‚
ä¸å…¶æ ¹æ®å®é™…ä¾‹å­æ¥é˜è¿°ï¼Œä¸å¦‚è¯•ç€å¯¹å®ç³»ç»Ÿçš„å·¥ä½œåŸç†è¿›è¡Œå®Œæ•´è€Œé€å½»çš„è§£é‡Šã€‚
å› æ­¤ï¼Œè¿™ç« æ„åœ¨è§£é‡Šå®ç³»ç»Ÿå¦‚ä½•ä½œä¸ºä¸€ä¸ªæ•´ä½“è¿ä½œï¼Œè€Œä¸æ˜¯ç»™æƒ³è¦ä¸€æ­¥æ­¥å¼•å¯¼ç¼–å†™å®çš„äººå‡†å¤‡çš„ã€‚</p>
<p>æ­¤å¤–ï¼šRust Book çš„ <a href="https://doc.rust-lang.org/book/ch19-06-macros.html">macro ä¸€èŠ‚</a> æ›´æµ…æ˜¾æ˜“æ‡‚ã€ç«™åœ¨æ›´é«˜çš„è§’åº¦åšå‡ºäº†è§£é‡Šï¼›
å‚è€ƒæ‰‹å†Œçš„ <a href="https://doc.rust-lang.org/reference/macros-by-example.html">macros-by-example</a> ä¸€èŠ‚ï¼Œ
å’Œæœ¬ä¹¦ <a href="./macros-practical.html">å®æˆ˜</a> ä¸€ç« éƒ½å¯¹å•ä¸ªå®çš„ä½¿ç”¨åšå‡ºäº†ç¤ºèŒƒã€‚</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="è¯­æ³•æ‹“å±•"><a class="header" href="#è¯­æ³•æ‹“å±•">è¯­æ³•æ‹“å±•</a></h1>
<p>åœ¨è¯´èµ· <code>macro_rules!</code> ï¼ˆå£°æ˜å®ï¼‰ä¹‹å‰ï¼Œå€¼å¾—è®¨è®ºå…¶åŸºäºçš„ä¸€èˆ¬æœºåˆ¶ï¼šè¯­æ³•æ‹“å±•ã€‚
ä¸ºäº†è§£é‡Šè¿™ä¸ªæœºåˆ¶ï¼Œæˆ‘ä»¬å¿…é¡»æ¢è®¨ Rust æºä»£ç </p>
<p>Before talking about <code>macro_rules!</code>, it is worthwhile to discuss the general mechanism they are built on:
syntax extensions. To do that, we must discuss how Rust source is processed by the compiler, and the
general mechanisms on which user-defined <code>macro_rules!</code> macros are built.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="source-analysis"><a class="header" href="#source-analysis">Source Analysis</a></h1>
<h3 id="tokenization"><a class="header" href="#tokenization">Tokenization</a></h3>
<p>The first stage of compilation for a Rust program is <a href="https://en.wikipedia.org/wiki/Lexical_analysis#Tokenization">tokenization</a>. This is where the source text is
transformed into a sequence of tokens (<em>i.e.</em> indivisible lexical units; the programming language
equivalent of &quot;words&quot;). Rust has various kinds of tokens, such as:</p>
<ul>
<li>Identifiers: <code>foo</code>, <code>Bambous</code>, <code>self</code>, <code>we_can_dance</code>, <code>LaCaravane</code>, â€¦</li>
<li>Literals: <code>42</code>, <code>72u32</code>, <code>0_______0</code>, <code>1.0e-40</code>, <code>&quot;ferris was here&quot;</code>, â€¦</li>
<li>Keywords: <code>_</code>, <code>fn</code>, <code>self</code>, <code>match</code>, <code>yield</code>, <code>macro</code>, â€¦</li>
<li>Symbols: <code>[</code>, <code>:</code>, <code>::</code>, <code>?</code>, <code>~</code>, <code>@</code><sup class="footnote-reference"><a href="#wither-at">1</a></sup>, â€¦</li>
</ul>
<p>â€¦among others. There are some things to note about the above: first, <code>self</code> is both an identifier
<em>and</em> a keyword. In almost all cases, <code>self</code> is a keyword, but it <em>is</em> possible for it to be
<em>treated</em> as an identifier, which will come up later (along with much cursing). Secondly, the list
of keywords includes some suspicious entries such as <code>yield</code> and <code>macro</code> that aren't <em>actually</em> in
the language, but <em>are</em> parsed by the compilerâ€”these are <a href="https://doc.rust-lang.org/reference/keywords.html#reserved-keywords">reserved</a> for future use. Third, the list
of symbols <em>also</em> includes entries that aren't used by the language. In the case of <code>&lt;-</code>, it is
vestigial: it was removed from the grammar, but not from the lexer. As a final point, note that
<code>::</code> is a distinct token; it is not simply two adjacent <code>:</code> tokens. The same is true of all
multi-character symbol tokens in Rust, as of Rust 1.2.<sup class="footnote-reference"><a href="#two-lexers">2</a></sup></p>
<div class="footnote-definition" id="wither-at"><sup class="footnote-definition-label">1</sup>
<p><code>@</code> has a purpose, though most people seem to forget about it completely: it is used
in patterns to bind a non-terminal part of the pattern to a name.</p>
</div>
<div class="footnote-definition" id="two-lexers"><sup class="footnote-definition-label">2</sup>
<p>Technically rust currently(1.46) has two lexers, <a href="https://github.com/rust-lang/rust/tree/master/compiler/rustc_lexer"><code>rustc_lexer</code></a> which only emits
single character symbols as tokens and the <a href="https://github.com/rust-lang/rust/tree/master/compiler/rustc_parse/src/lexer">lexer</a> in <a href="https://github.com/rust-lang/rust/tree/master/compiler/rustc_parse"><code>rustc_parse</code></a> which sees multi-character
symbols as distinct tokens.</p>
</div>
<p>As a point of comparison, it is at <em>this</em> stage that some languages have their macro layer, though
Rust does <em>not</em>. For example, C/C++ macros are <em>effectively</em> processed at this point.
<sup class="footnote-reference"><a href="#lies-damn-lies-cpp">3</a></sup> This is why the following code works:
<sup class="footnote-reference"><a href="#cpp-it-seemed-like-a-good-idea-at-the-time">4</a></sup></p>
<pre><code class="language-c">#define SUB void
#define BEGIN {
#define END }

SUB main() BEGIN
    printf(&quot;Oh, the horror!\n&quot;);
END
</code></pre>
<div class="footnote-definition" id="lies-damn-lies-cpp"><sup class="footnote-definition-label">3</sup>
<p>In fact, the C preprocessor uses a different lexical structure to C itself,
but the distinction is <em>broadly</em> irrelevant.</p>
</div>
<div class="footnote-definition" id="cpp-it-seemed-like-a-good-idea-at-the-time"><sup class="footnote-definition-label">4</sup>
<p><em>Whether</em> it should work is an entirely <em>different</em>
question.</p>
</div>
<h3 id="parsing"><a class="header" href="#parsing">Parsing</a></h3>
<p>The next stage is parsing, where the stream of tokens is turned into an <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">Abstract Syntax Tree</a> (AST).
This involves building up the syntactic structure of the program in memory. For example, the token
sequence <code>1 + 2</code> is transformed into the equivalent of:</p>
<pre><code class="language-text">â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ BinOp   â”‚ â”Œâ•´â”‚ LitInt  â”‚
â”‚ op: Add â”‚ â”‚ â”‚ val: 1  â”‚
â”‚ lhs: â—Œ  â”‚â•¶â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚ rhs: â—Œ  â”‚â•¶â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â•´â”‚ LitInt  â”‚
              â”‚ val: 2  â”‚
              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<p>The AST contains the structure of the <em>entire</em> program, though it is based on purely <em>lexical</em>
information. For example, although the compiler may know that a particular expression is referring
to a variable called <code>a</code>, at this stage, it has <em>no way</em> of knowing what <code>a</code> is, or even <em>where</em> it
comes from.</p>
<p>It is <em>after</em> the AST has been constructed that macros are processed. However, before we can discuss
that, we have to talk about token trees.</p>
<h2 id="token-trees"><a class="header" href="#token-trees">Token trees</a></h2>
<p>Token trees are somewhere between tokens and the AST. Firstly, <em>almost</em> all tokens are also token
trees; more specifically, they are <em>leaves</em>. There is one other kind of thing that can be a token
tree leaf, but we will come back to that later.</p>
<p>The only basic tokens that are <em>not</em> leaves are the &quot;grouping&quot; tokens: <code>(...)</code>, <code>[...]</code>, and <code>{...}</code>.
These three are the <em>interior nodes</em> of token trees, and what give them their structure. To give a
concrete example, this sequence of tokens:</p>
<pre><code class="language-text">a + b + (c + d[0]) + e
</code></pre>
<p>would be parsed into the following token trees:</p>
<pre><code class="language-text">Â«aÂ» Â«+Â» Â«bÂ» Â«+Â» Â«(   )Â» Â«+Â» Â«eÂ»
          â•­â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
           Â«cÂ» Â«+Â» Â«dÂ» Â«[   ]Â»
                        â•­â”€â”´â”€â•®
                         Â«0Â»
</code></pre>
<p>Note that this has <em>no relationship</em> to the AST the expression would produce; instead of a single
root node, there are <em>seven</em> token trees at the root level. For reference, the AST would be:</p>
<pre><code class="language-text">              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚ BinOp   â”‚
              â”‚ op: Add â”‚
            â”Œâ•´â”‚ lhs: â—Œ  â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚ rhs: â—Œ  â”‚â•¶â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Var     â”‚â•¶â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â•´â”‚ BinOp   â”‚
â”‚ name: a â”‚                 â”‚ op: Add â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â”Œâ•´â”‚ lhs: â—Œ  â”‚
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚ rhs: â—Œ  â”‚â•¶â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚ Var     â”‚â•¶â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â•´â”‚ BinOp   â”‚
              â”‚ name: b â”‚                 â”‚ op: Add â”‚
              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â”Œâ•´â”‚ lhs: â—Œ  â”‚
                            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚ rhs: â—Œ  â”‚â•¶â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                            â”‚ BinOp   â”‚â•¶â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â•´â”‚ Var     â”‚
                            â”‚ op: Add â”‚                 â”‚ name: e â”‚
                          â”Œâ•´â”‚ lhs: â—Œ  â”‚                 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚ rhs: â—Œ  â”‚â•¶â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚ Var     â”‚â•¶â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â•´â”‚ Index   â”‚
              â”‚ name: c â”‚               â”Œâ•´â”‚ arr: â—Œ  â”‚
              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚ ind: â—Œ  â”‚â•¶â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                            â”‚ Var     â”‚â•¶â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â•´â”‚ LitInt  â”‚
                            â”‚ name: d â”‚                 â”‚ val: 0  â”‚
                            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<p>It is important to understand the distinction between the AST and token trees. When writing macros,
you have to deal with <em>both</em> as distinct things.</p>
<p>One other aspect of this to note: it is <em>impossible</em> to have an unpaired paren, bracket or brace;
nor is it possible to have incorrectly nested groups in a token tree.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="macros-in-the-ast"><a class="header" href="#macros-in-the-ast">Macros in the AST</a></h1>
<p>As previously mentioned, macro processing in Rust happens <em>after</em> the construction of the AST. As
such, the syntax used to invoke a macro <em>must</em> be a proper part of the language's syntax. In fact,
there are several &quot;syntax extension&quot; forms which are part of Rust's syntax. Specifically, the
following 4 forms (by way of examples):</p>
<ul>
<li><code># [ $arg ]</code>; <em>e.g.</em> <code>#[derive(Clone)]</code>, <code>#[no_mangle]</code>, â€¦</li>
<li><code># ! [ $arg ]</code>; <em>e.g.</em> <code>#![allow(dead_code)]</code>, <code>#![crate_name=&quot;blang&quot;]</code>, â€¦</li>
<li><code>$name ! $arg</code>; <em>e.g.</em> <code>println!(&quot;Hi!&quot;)</code>, <code>concat!(&quot;a&quot;, &quot;b&quot;)</code>, â€¦</li>
<li><code>$name ! $arg0 $arg1</code>; <em>e.g.</em> <code>macro_rules! dummy { () =&gt; {}; }</code>.</li>
</ul>
<p>The first two are <a href="https://doc.rust-lang.org/reference/attributes.html">attributes</a> which annotate items, expressions and statements. They can be
classified into different kinds, <a href="https://doc.rust-lang.org/reference/attributes.html#built-in-attributes-index">built-in attributes</a>, <a href="https://doc.rust-lang.org/reference/procedural-macros.html#attribute-macros">macro attributes</a> and <a href="https://doc.rust-lang.org/reference/procedural-macros.html#derive-macro-helper-attributes">derive attributes</a>.
<a href="https://doc.rust-lang.org/reference/procedural-macros.html#attribute-macros">macro attributes</a> and <a href="https://doc.rust-lang.org/reference/procedural-macros.html#derive-macro-helper-attributes">derive attributes</a> can be implemented with the second macro system that Rust
offers, <a href="https://doc.rust-lang.org/reference/procedural-macros.html">procedural macros</a>. <a href="https://doc.rust-lang.org/reference/attributes.html#built-in-attributes-index">built-in attributes</a> on the other hand are attributes implemented by
the compiler.</p>
<p>The third form, <code>$name ! $arg</code>,  is the one of interest to us: function-like macros. It is the form
available for use with <code>macro_rules!</code> macros. Note that this form is not <em>limited</em> to <code>macro_rules!</code>
macros: it is a generic syntax extension form. For example, whilst <a href="https://doc.rust-lang.org/std/macro.format.html"><code>format!</code></a> is a macro,
<a href="https://doc.rust-lang.org/std/macro.format_args.html"><code>format_args!</code></a> (which is used to <em>implement</em> <a href="https://doc.rust-lang.org/std/macro.format.html"><code>format!</code></a>) is <em>not</em>.</p>
<p>The fourth form is essentially a variation which is <em>not</em> available to macros. In fact, the only case
where this form is used <em>at all</em> is with <code>macro_rules!</code> itself which, again we will come back to.</p>
<p>Disregarding all but the third form (<code>$name ! $arg</code>), the question becomes: how does the Rust parser
know what <code>$arg</code> looks like for every possible syntax extension? The answer is that it doesn't
<em>have to</em>. Instead, the argument of a syntax extension invocation is a <em>single</em> token tree. More
specifically, it is a single, <em>non-leaf</em> token tree; <code>(...)</code>, <code>[...]</code>, or <code>{...}</code>. With that
knowledge, it should become apparent how the parser can understand all of the following invocation
forms:</p>
<pre><code class="language-rust ignore">bitflags! {
    struct Color: u8 {
        const RED    = 0b0001,
        const GREEN  = 0b0010,
        const BLUE   = 0b0100,
        const BRIGHT = 0b1000,
    }
}

lazy_static! {
    static ref FIB_100: u32 = {
        fn fib(a: u32) -&gt; u32 {
            match a {
                0 =&gt; 0,
                1 =&gt; 1,
                a =&gt; fib(a-1) + fib(a-2)
            }
        }

        fib(100)
    };
}

fn main() {
    use Color::*;
    let colors = vec![RED, GREEN, BLUE];
    println!(&quot;Hello, World!&quot;);
}
</code></pre>
<p>Although the above invocations may <em>look</em> like they contain various kinds of Rust code, the parser
simply sees a collection of meaningless token trees. To make this clearer, we can replace all these
syntactic &quot;black boxes&quot; with â¬š, leaving us with:</p>
<pre><code class="language-text">bitflags! â¬š

lazy_static! â¬š

fn main() {
    let colors = vec! â¬š;
    println! â¬š;
}
</code></pre>
<p>Just to reiterate: the parser does not assume <em>anything</em> about â¬š; it remembers the tokens it
contains, but doesn't try to <em>understand</em> them. This means â¬š can be anything, even invalid Rust! As
to why this is a good thing, we will come back to that at a later point.</p>
<p>The important takeaways are:</p>
<ul>
<li>There are multiple kinds of syntax extension in Rust. We will <em>only</em> be talking about macros
defined by the <code>macro_rules!</code> construct.</li>
<li>Just because you see something of the form <code>$name! $arg</code>, doesn't mean it's actually a macro; it
might be another kind of syntax extension, a procedural macro for example.</li>
<li>The input to every macro is a single non-leaf token tree.</li>
<li>Macros (really, syntax extensions in general) are parsed as <em>part</em> of the abstract syntax tree.</li>
</ul>
<blockquote>
<p><strong>Aside</strong>: due to the first point, some of what will be said below (including the next paragraph)
will apply to syntax extensions <em>in general</em>.<sup class="footnote-reference"><a href="#writer-is-lazy">1</a></sup></p>
</blockquote>
<div class="footnote-definition" id="writer-is-lazy"><sup class="footnote-definition-label">1</sup>
<p>This is rather convenient as &quot;macro&quot; is much quicker and easier to type than
&quot;syntax extension&quot;.</p>
</div>
<p>The last point is the most important, as it has <em>significant</em> implications. Because macros are
parsed into the AST, they can <strong>only</strong> appear in positions where they are explicitly supported.
Specifically macros can appear in place of the following:</p>
<ul>
<li>Patterns</li>
<li>Statements</li>
<li>Expressions</li>
<li>Items(this includes <code>impl</code> Items)</li>
<li>Types</li>
</ul>
<p>Some things <em>not</em> on this list:</p>
<ul>
<li>Identifiers</li>
<li>Match arms</li>
<li>Struct fields</li>
</ul>
<p>There is absolutely, definitely <em>no way</em> to use macros in any position <em>not</em> on the first list.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="expansion"><a class="header" href="#expansion">Expansion</a></h1>
<p>Expansion is a relatively simple affair. At some point <em>after</em> the construction of the AST, but
before the compiler begins constructing its semantic understanding of the program, it will expand
all macros.</p>
<p>This involves traversing the AST, locating macro invocations and replacing them with their
expansion. In the case of non-macro syntax extensions, <em>how</em> this happens is up to the particular
syntax extension. That said, syntax extensions go through <em>exactly</em> the same process that macros do
once their expansion is complete.</p>
<p>Once the compiler has run a syntax extension, it expects the result to be parsable as one of a
limited set of syntax elements, based on context. For example, if you invoke a macro at module scope,
the compiler will parse the result into an AST node that represents an item. If you invoke a macro
in expression position, the compiler will parse the result into an expression AST node.</p>
<p>In fact, it can turn a syntax extension result into any of the following:</p>
<ul>
<li>an expression,</li>
<li>a pattern,</li>
<li>a type,</li>
<li>zero or more items, or</li>
<li>zero or more statements.</li>
</ul>
<p>In other words, <em>where</em> you can invoke a macro determines what its result will be interpreted as.</p>
<p>The compiler will take this AST node and completely replace the macro's invocation node with the
output node. <em>This is a structural operation</em>, not a textural one!</p>
<p>For example, consider the following:</p>
<pre><code class="language-rust ignore">let eight = 2 * four!();
</code></pre>
<p>We can visualize this partial AST as follows:</p>
<pre><code class="language-text">â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Let         â”‚
â”‚ name: eight â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ init: â—Œ     â”‚â•¶â”€â•´â”‚ BinOp   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚ op: Mul â”‚
                â”Œâ•´â”‚ lhs: â—Œ  â”‚
     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚ rhs: â—Œ  â”‚â•¶â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     â”‚ LitInt â”‚â•¶â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â•´â”‚ Macro      â”‚
     â”‚ val: 2 â”‚                 â”‚ name: four â”‚
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜                 â”‚ body: ()   â”‚
                                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<p>From context, <code>four!()</code> <em>must</em> expand to an expression (the initializer can <em>only</em> be an expression).
Thus, whatever the actual expansion is, it will be interpreted as a complete expression. In this
case, we will assume <code>four!</code> is defined such that it expands to the expression <code>1 + 3</code>.  As a result,
expanding this invocation will result in the AST changing to:</p>
<pre><code class="language-text">â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Let         â”‚
â”‚ name: eight â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ init: â—Œ     â”‚â•¶â”€â•´â”‚ BinOp   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚ op: Mul â”‚
                â”Œâ•´â”‚ lhs: â—Œ  â”‚
     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚ rhs: â—Œ  â”‚â•¶â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     â”‚ LitInt â”‚â•¶â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â•´â”‚ BinOp   â”‚
     â”‚ val: 2 â”‚                 â”‚ op: Add â”‚
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â”Œâ•´â”‚ lhs: â—Œ  â”‚
                   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚ rhs: â—Œ  â”‚â•¶â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”
                   â”‚ LitInt â”‚â•¶â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â•´â”‚ LitInt â”‚
                   â”‚ val: 1 â”‚                 â”‚ val: 3 â”‚
                   â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜                 â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<p>This can be written out like so:</p>
<pre><code class="language-rust ignore">let eight = 2 * (1 + 3);
</code></pre>
<p>Note that we added parentheses <em>despite</em> them not being in the expansion.  Remember that the
compiler always treats the expansion of a macro as a complete AST node, <strong>not</strong> as a mere sequence
of tokens. To put it another way, even if you don't explicitly wrap a complex expression in
parentheses, there is no way for the compiler to &quot;misinterpret&quot; the result, or change the order of
evaluation.</p>
<p>It is important to understand that macro expansions are treated as AST nodes, as this design has two
further implications:</p>
<ul>
<li>In addition to there being a limited number of invocation <em>positions</em>, macros can <em>only</em> expand to
the kind of AST node the parser <em>expects</em> at that position.</li>
<li>As a consequence of the above, macros <em>absolutely cannot</em> expand to incomplete or syntactically
invalid constructs.</li>
</ul>
<p>There is one further thing to note about expansion: what happens when a syntax extension expands to
something that contains <em>another</em> syntax extension invocation. For example, consider an alternative
definition of <code>four!</code>; what happens if it expands to <code>1 + three!()</code>?</p>
<pre><code class="language-rust ignore">let x = four!();
</code></pre>
<p>Expands to:</p>
<pre><code class="language-rust ignore">let x = 1 + three!();
</code></pre>
<p>This is resolved by the compiler checking the result of expansions for additional macro invocations,
and expanding them. Thus, a second expansion step turns the above into:</p>
<pre><code class="language-rust ignore">let x = 1 + 3;
</code></pre>
<p>The takeaway here is that expansion happens in &quot;passes&quot;; as many as is needed to completely expand
all invocations.</p>
<p>Well, not <em>quite</em>. In fact, the compiler imposes an upper limit on the number of such recursive
passes it is willing to run before giving up. This is known as the macro recursion limit and
defaults to 32. If the 32nd expansion contains a macro invocation, the compiler will abort with an
error indicating that the recursion limit was exceeded.</p>
<p>This limit can be raised using the <code>#![recursion_limit=&quot;â€¦&quot;]</code> <a href="https://doc.rust-lang.org/reference/attributes/limits.html#the-recursion_limit-attribute">attribute</a>, though it <em>must</em> be done
crate-wide. Generally, it is recommended to try and keep macros below this limit wherever possible
as it may impact compilation times.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="macro_rules"><a class="header" href="#macro_rules"><code>macro_rules!</code></a></h1>
<p>With all that in mind, we can introduce <code>macro_rules!</code> itself. As noted previously, <code>macro_rules!</code>
is <em>itself</em> a syntax extension, meaning it is <em>technically</em> not part of the Rust syntax. It uses the
following forms:</p>
<pre><code class="language-rust ignore">macro_rules! $name {
    $rule0 ;
    $rule1 ;
    // â€¦
    $ruleN ;
}
</code></pre>
<p>There must be <em>at least</em> one rule, and you can omit the semicolon after the last rule. You can use
brackets(<code>[]</code>), parentheses(<code>()</code>) or braces(<code>{}</code>). Invocations with <code>{ .. }</code> and <code>( ... );</code>, notice
the trailing semicolon, will <em>always</em> be parsed as an <em>item</em>.</p>
<p>Each <em>&quot;rule&quot;</em> looks like the following:</p>
<pre><code class="language-ignore">    ($matcher) =&gt; {$expansion}
</code></pre>
<p>Like before, the types of parentheses used can be any kind, but parentheses around the matcher and
braces around the expansion are somewhat conventional. The expansion part of a rule is also called
its <em>transcriber</em>.</p>
<p>If you are wondering, the <code>macro_rules!</code> invocation expands to... <em>nothing</em>.  At least, nothing that
appears in the AST; rather, it manipulates compiler-internal structures to register the macro. As
such, you can <em>technically</em> use <code>macro_rules!</code> in any position where an empty expansion is valid.</p>
<h2 id="matching"><a class="header" href="#matching">Matching</a></h2>
<p>When a <code>macro_rules!</code> macro is invoked, the <code>macro_rules!</code> interpreter goes through the rules one by
one, in declaration order. For each rule, it tries to match the contents of the input token tree
against that rule's <code>matcher</code>. A matcher must match the <em>entirety</em> of the input to be considered a
match.</p>
<p>If the input matches the matcher, the invocation is replaced by the <code>expansion</code>; otherwise, the next
rule is tried. If all rules fail to match, macro expansion fails with an error.</p>
<p>The simplest example is of an empty matcher:</p>
<pre><code class="language-rust ignore">macro_rules! four {
    () =&gt; { 1 + 3 };
}
</code></pre>
<p>This matches if and only if the input is also empty (<em>i.e.</em> <code>four!()</code>, <code>four![]</code> or <code>four!{}</code>).</p>
<p>Note that the specific grouping tokens you use when you invoke the macro <em>are not</em> matched. That is,
you can invoke the above macro as <code>four![]</code> and it will still match. Only the <em>contents</em> of the
input token tree are considered.</p>
<p>Matchers can also contain literal token trees, which must be matched exactly. This is done by simply
writing the token trees normally. For example, to match the sequence <code>4 fn ['spang &quot;whammo&quot;] @_@</code>,
you would write:</p>
<pre><code class="language-rust ignore">macro_rules! gibberish {
    (4 fn ['spang &quot;whammo&quot;] @_@) =&gt; {...};
}
</code></pre>
<p>You can use any token tree that you can write.</p>
<h2 id="metavariables"><a class="header" href="#metavariables">Metavariables</a></h2>
<p>Matchers can also contain captures. These allow input to be matched based on some general grammar
category, with the result captured to a metavariable which can then be substituted into the output.</p>
<p>Captures are written as a dollar (<code>$</code>) followed by an identifier, a colon (<code>:</code>), and finally the
kind of capture which is also called the fragment-specifier, which must be one of the following:</p>
<ul>
<li><code>block</code>: a block (i.e. a block of statements and/or an expression, surrounded by braces)</li>
<li><code>expr</code>: an expression</li>
<li><code>ident</code>: an identifier (this includes keywords)</li>
<li><code>item</code>: an item, like a function, struct, module, impl, etc.</li>
<li><code>lifetime</code>: a lifetime (e.g. <code>'foo</code>, <code>'static</code>, ...)</li>
<li><code>literal</code>: a literal (e.g. <code>&quot;Hello World!&quot;</code>, <code>3.14</code>, <code>'ğŸ¦€'</code>, ...)</li>
<li><code>meta</code>: a meta item; the things that go inside the <code>#[...]</code> and <code>#![...]</code> attributes</li>
<li><code>pat</code>: a pattern</li>
<li><code>path</code>: a path (e.g. <code>foo</code>, <code>::std::mem::replace</code>, <code>transmute::&lt;_, int&gt;</code>, â€¦)</li>
<li><code>stmt</code>: a statement</li>
<li><code>tt</code>: a single token tree</li>
<li><code>ty</code>: a type</li>
<li><code>vis</code>: a possible empty visibility qualifier (e.g. <code>pub</code>, <code>pub(in crate)</code>, ...)</li>
</ul>
<p>For more in-depth description of the fragement specifiers, check out the
<a href="macros/./minutiae/fragment-specifiers.html">Fragment Specifiers</a> chapter.</p>
<p>For example, here is a <code>macro_rules!</code> macro which captures its input as an expression under the
metavariable <code>$e</code>:</p>
<pre><code class="language-rust ignore">macro_rules! one_expression {
    ($e:expr) =&gt; {...};
}
</code></pre>
<p>These metavariables leverage the Rust compiler's parser, ensuring that they are always &quot;correct&quot;. An
<code>expr</code> metavariables will <em>always</em> capture a complete, valid expression for the version of Rust being
compiled.</p>
<p>You can mix literal token trees and metavariables, within limits ([explained below]).</p>
<p>To refer to a metavariable you simply write <code>$name</code>, as the type of the variable is already
specified in the matcher. For example:</p>
<pre><code class="language-rust ignore">macro_rules! times_five {
    ($e:expr) =&gt; { 5 * $e };
}
</code></pre>
<p>Much like macro expansion, metavariables are substituted as complete AST nodes. This means that no
matter what sequence of tokens is captured by <code>$e</code>, it will be interpreted as a single, complete
expression.</p>
<p>You can also have multiple metavariables in a single matcher:</p>
<pre><code class="language-rust ignore">macro_rules! multiply_add {
    ($a:expr, $b:expr, $c:expr) =&gt; { $a * ($b + $c) };
}
</code></pre>
<p>And use them as often as you like in the expansion:</p>
<pre><code class="language-rust ignore">macro_rules! discard {
    ($e:expr) =&gt; {};
}
macro_rules! repeat {
    ($e:expr) =&gt; { $e; $e; $e; };
}
</code></pre>
<p>There is also a special metavariable called <a href="macros/./minutiae/hygiene.html#crate"><code>$crate</code></a> which can be used to refer to the current
crate.</p>
<h2 id="repetitions"><a class="header" href="#repetitions">Repetitions</a></h2>
<p>Matchers can contain repetitions. These allow a sequence of tokens to be matched. These have the
general form <code>$ ( ... ) sep rep</code>.</p>
<ul>
<li>
<p><code>$</code> is a literal dollar token.</p>
</li>
<li>
<p><code>( ... )</code> is the paren-grouped matcher being repeated.</p>
</li>
<li>
<p><code>sep</code> is an <em>optional</em> separator token. It may not be a delimiter or one
of the repetition operators. Common examples are <code>,</code> and <code>;</code>.</p>
</li>
<li>
<p><code>rep</code> is the <em>required</em> repeat operator. Currently, this can be:</p>
<ul>
<li><code>?</code>: indicating at most one repetition</li>
<li><code>*</code>: indicating zero or more repetitions</li>
<li><code>+</code>: indicating one or more repetitions</li>
</ul>
<p>Since <code>?</code> represents at most one occurrence, it cannot be used with a separator.</p>
</li>
</ul>
<p>Repetitions can contain any other valid matcher, including literal token trees, metavariables, and
other repetitions allowing arbitrary nesting.</p>
<p>Repetitions use the same syntax in the expansion and repeated metavariables can only be accessed
inside of repetitions in the expansion.</p>
<p>For example, below is a macro which formats each element as a string. It matches zero or more
comma-separated expressions and expands to an expression that constructs a vector.</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! vec_strs {
    (
        // Start a repetition:
        $(
            // Each repeat must contain an expression...
            $element:expr
        )
        // ...separated by commas...
        ,
        // ...zero or more times.
        *
    ) =&gt; {
        // Enclose the expansion in a block so that we can use
        // multiple statements.
        {
            let mut v = Vec::new();

            // Start a repetition:
            $(
                // Each repeat will contain the following statement, with
                // $element replaced with the corresponding expression.
                v.push(format!(&quot;{}&quot;, $element));
            )*

            v
        }
    };
}

fn main() {
    let s = vec_strs![1, &quot;a&quot;, true, 3.14159f32];
    assert_eq!(s, &amp;[&quot;1&quot;, &quot;a&quot;, &quot;true&quot;, &quot;3.14159&quot;]);
}
</code></pre></pre>
<p>You can repeat multiple metavariables in a single repetition as long as all metavariables repeat
equally often. So this invocation of the following macro works:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! repeat_two {
    ($($i:ident)*, $($i2:ident)*) =&gt; {
        $( let $i: (); let $i2: (); )*
    }
}

repeat_two!( a b c d e f, u v w x y z );
<span class="boring">}
</span></code></pre></pre>
<p>But this does not:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">macro_rules! repeat_two {
</span><span class="boring">    ($($i:ident)*, $($i2:ident)*) =&gt; {
</span><span class="boring">        $( let $i: (); let $i2: (); )*
</span><span class="boring">    }
</span><span class="boring">}
</span>
repeat_two!( a b c d e f, x y z );
<span class="boring">}
</span></code></pre></pre>
<p>failing with the following error</p>
<pre><code>error: meta-variable `i` repeats 6 times, but `i2` repeats 3 times
 --&gt; src/main.rs:6:10
  |
6 |         $( let $i: (); let $i2: (); )*
  |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
</code></pre>
<p>Â </p>
<p>For the complete grammar definition you may want to consult the 
<a href="https://doc.rust-lang.org/reference/macros-by-example.html#macros-by-example">Macros By Example</a>
chapter of the Rust reference.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="minutiae"><a class="header" href="#minutiae">Minutiae</a></h1>
<p>This section goes through some of the finer details of the <code>macro_rules!</code> system. At a minimum, you should
try to be at least <em>aware</em> of these details and issues.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="fragment-specifiers"><a class="header" href="#fragment-specifiers">Fragment Specifiers</a></h1>
<p>As shown in the [<code>macro_rules</code>] chapter, Rust, as of 1.46, has 13 fragment specifiers. This section
will go a bit more into detail for some of them and tries to always show a few examples of what a
matcher can match with.</p>
<blockquote>
<p>Note that capturing with anything but the <code>ident</code>, <code>lifetime</code> and <code>tt</code> fragments will render the
captured AST opaque, making it impossible to further inspect it in future macro invocations.</p>
</blockquote>
<ul>
<li><a href="macros/minutiae/fragment-specifiers.html#item"><code>item</code></a></li>
<li><a href="macros/minutiae/fragment-specifiers.html#block"><code>block</code></a></li>
<li><a href="macros/minutiae/fragment-specifiers.html#stmt"><code>stmt</code></a></li>
<li><a href="macros/minutiae/fragment-specifiers.html#pat"><code>pat</code></a></li>
<li><a href="macros/minutiae/fragment-specifiers.html#expr"><code>expr</code></a></li>
<li><a href="macros/minutiae/fragment-specifiers.html#ty"><code>ty</code></a></li>
<li><a href="macros/minutiae/fragment-specifiers.html#ident"><code>ident</code></a></li>
<li><a href="macros/minutiae/fragment-specifiers.html#path"><code>path</code></a></li>
<li><a href="macros/minutiae/fragment-specifiers.html#tt"><code>tt</code></a></li>
<li><a href="macros/minutiae/fragment-specifiers.html#meta"><code>meta</code></a></li>
<li><a href="macros/minutiae/fragment-specifiers.html#lifetime"><code>lifetime</code></a></li>
<li><a href="macros/minutiae/fragment-specifiers.html#vis"><code>vis</code></a></li>
<li><a href="macros/minutiae/fragment-specifiers.html#literal"><code>literal</code></a></li>
</ul>
<h2 id="item"><a class="header" href="#item"><code>item</code></a></h2>
<p>The <code>item</code> fragment simply matches any of Rust's
<a href="https://doc.rust-lang.org/reference/items.html">item</a> <em>definitions</em>, not identifiers that refer to
items. Item examples:</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! items {
    ($($item:item)*) =&gt; ();
}

items! {
    struct Foo;
    enum Bar {
        Baz
    }
    impl Foo {}
    /*...*/
}
<span class="boring">fn main() {}
</span></code></pre></pre>
<h2 id="block"><a class="header" href="#block"><code>block</code></a></h2>
<p>The <code>block</code> fragment solely matches a <a href="https://doc.rust-lang.org/reference/expressions/block-expr.html">block expression</a>,
which consists of an opening <code>{</code> brace, followed by any amount of statements and finally followed
by a closing <code>}</code> brace.</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! blocks {
    ($($block:block)*) =&gt; ();
}

blocks! {
    {}
    {
        let zig;
    }
    { 2 }
}
<span class="boring">fn main() {}
</span></code></pre></pre>
<h2 id="stmt"><a class="header" href="#stmt"><code>stmt</code></a></h2>
<p>The <code>statement</code> fragment solely matches a <a href="https://doc.rust-lang.org/reference/statements.html">statement</a>
without its trailing semicolon, unless its an item statement that requires one. What would be an
item statement that requires one? A Unit-Struct would be a simple one, as defining one requires a
trailing semicolon. </p>
<p>Let's use a simple example to show exactly what is meant with this. We use a macro that merely emits
what it captures:</p>
<pre><code class="language-rust ignore">macro_rules! statements {
    ($($stmt:stmt)*) =&gt; ($($stmt)*);
}

fn main() {
    statements! {
        struct Foo;
        fn foo() {}
        let zig = 3
        let zig = 3;
        3
        3;
        if true {} else {}
        {}
    }
}

</code></pre>
<p>Expanding this, via the <a href="https://play.rust-lang.org/">playground</a> for example<sup class="footnote-reference"><a href="#debugging">1</a></sup>, gives us roughly the
following:</p>
<pre><code class="language-rust ignore">/* snip */

fn main() {
    struct Foo;
    fn foo() { }
    let zig = 3;
    let zig = 3;
    ;
    3;
    3;
    ;
    if true { } else { }
    { }
}
</code></pre>
<p>From this we can tell a few things:</p>
<p>The first you should be able to see immediately is that while the <code>stmt</code> fragment doesn't capture
trailing semicolons, it still emits them when required, even if the statement is already followed by
one. The simple reason for that is that semicolons on their own are already valid statements. So we
are actually invoking our macro here with not 8 statements, but 11!</p>
<p>Another thing you should be able to notice here is that the trailing semicolon of the <code>struct Foo;</code>
item statement is being matched, otherwise we would've seen an extra one like in the other cases.
This makes sense as we already said, that for item statements that require one, the trailing
semicolon will be matched with.</p>
<p>A last observation is that expressions get emitted back with a trailing semicolon, unless the
expression solely consists of only a block expression or control flow expression.</p>
<p>The fine details of what was just mentioned here can be looked up in the
<a href="https://doc.rust-lang.org/reference/statements.html">reference</a>.</p>
<div class="footnote-definition" id="debugging"><sup class="footnote-definition-label">1</sup>
<p>See the <a href="macros/minutiae/./debugging.html">debugging chapter</a> for tips on how to do this.</p>
</div>
<h2 id="pat"><a class="header" href="#pat"><code>pat</code></a></h2>
<p>The <code>pat</code> fragment matches any kind of <a href="https://doc.rust-lang.org/reference/patterns.html">pattern</a>.</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! patterns {
    ($($pat:pat)*) =&gt; ();
}

patterns! {
    &quot;literal&quot;
    _
    0..5
    ref mut PatternsAreNice
}
<span class="boring">fn main() {}
</span></code></pre></pre>
<h2 id="expr"><a class="header" href="#expr"><code>expr</code></a></h2>
<p>The <code>expr</code> fragment matches any kind of <a href="https://doc.rust-lang.org/reference/expressions.html">expression</a>
(Rust has a lot of them, given it <em>is</em> an expression orientated language).</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! expressions {
    ($($expr:expr)*) =&gt; ();
}

expressions! {
    &quot;literal&quot;
    funcall()
    future.await
    break 'foo bar
}
<span class="boring">fn main() {}
</span></code></pre></pre>
<h2 id="ty"><a class="header" href="#ty"><code>ty</code></a></h2>
<p>The <code>ty</code> fragment matches any kind of <a href="https://doc.rust-lang.org/reference/types.html#type-expressions">type expression</a>.
A type expression is the syntax with which one refers to a type in the language.</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! types {
    ($($type:ty)*) =&gt; ();
}

types! {
    foo::bar
    bool
    [u8]
}
<span class="boring">fn main() {}
</span></code></pre></pre>
<h2 id="ident"><a class="header" href="#ident"><code>ident</code></a></h2>
<p>The <code>ident</code> fragment matches an <a href="https://doc.rust-lang.org/reference/identifiers.html">identifier</a>
or <em>keyword</em>.</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! idents {
    ($($ident:ident)*) =&gt; ();
}

idents! {
    // _ &lt;- This is not an ident, it is a pattern
    foo
    async
    O_________O
    _____O_____
}
<span class="boring">fn main() {}
</span></code></pre></pre>
<h2 id="path"><a class="header" href="#path"><code>path</code></a></h2>
<p>The <code>path</code> fragment matches a so called <a href="https://doc.rust-lang.org/reference/paths.html#paths-in-types">TypePath</a>
style path.</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! paths {
    ($($path:path)*) =&gt; ();
}

paths! {
    ASimplePath
    ::A::B::C::D
    G::&lt;eneri&gt;::C
}
<span class="boring">fn main() {}
</span></code></pre></pre>
<h2 id="tt"><a class="header" href="#tt"><code>tt</code></a></h2>
<p>The <code>tt</code> fragment matches a TokenTree. If you need a refresher on what exactly a TokenTree was you
may want to revisit the <a href="macros/minutiae/../syntax/source-analysys.html#token-trees">TokenTree chapter</a> of this
book. The <code>tt</code> fragment is one of the most powerful fragments, as it can match nearly anything while
still allowing you to inspect the contents of it at a later state in the macro.</p>
<h2 id="meta"><a class="header" href="#meta"><code>meta</code></a></h2>
<p>The <code>meta</code> fragment matches an <a href="https://doc.rust-lang.org/reference/attributes.html">attribute</a>, to
be more precise, the contents of an attribute. You will usually see this fragment being used in a
matcher like <code>#[$meta:meta]</code> or <code>#![$meta:meta]</code>.</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! metas {
    ($($meta:meta)*) =&gt; ();
}

metas! {
    ASimplePath
    super::man
    path = &quot;home&quot;
    foo(bar)
}
<span class="boring">fn main() {}
</span></code></pre></pre>
<blockquote>
<p>A neat thing about doc comments: They are actually attributes in the form of <code>#[doc=&quot;â€¦&quot;]</code> where
the <code>...</code> is the actual comment string, meaning you can act on doc comments in macros!</p>
</blockquote>
<h2 id="lifetime"><a class="header" href="#lifetime"><code>lifetime</code></a></h2>
<p>The <code>lifetime</code> fragment matches a <a href="https://doc.rust-lang.org/reference/tokens.html#lifetimes-and-loop-labels">lifetime or label</a>.
It's quite similar to <a href="macros/minutiae/fragment-specifiers.html#ident"><code>ident</code></a> but with a prepended <code>'</code>.</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! lifetimes {
    ($($lifetime:lifetime)*) =&gt; ();
}

lifetimes! {
    'static
    'shiv
    '_
}
<span class="boring">fn main() {}
</span></code></pre></pre>
<h2 id="vis"><a class="header" href="#vis"><code>vis</code></a></h2>
<p>The <code>vis</code> fragment matches a <em>possibly empty</em> <a href="https://doc.rust-lang.org/reference/visibility-and-privacy.html">Visibility qualifier</a>.
Emphasis lies on the <em>possibly empty</em> part. You can think of this fragment having an implicit <code>?</code>
repetition to it, meaning you don't, and in fact cannot, wrap it in a direct repetition.</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! visibilities {
    //         âˆ¨~~Note this comma, since we cannot repeat a `vis` fragment on its own 
    ($($vis:vis,)*) =&gt; ();
}

visibilities! {
    ,
    pub,
    pub(crate),
    pub(in super),
    pub(in some_path),
}
<span class="boring">fn main() {}
</span></code></pre></pre>
<h2 id="literal"><a class="header" href="#literal"><code>literal</code></a></h2>
<p>The <code>literal</code> fragment matches any <a href="https://doc.rust-lang.org/reference/expressions/literal-expr.html">literal expression</a>.</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! literals {
    ($($literal:literal)*) =&gt; ();
}

literals! {
    -1
    &quot;hello world&quot;
    2.3
    b'b'
    true
}
<span class="boring">fn main() {}
</span></code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="metavariables-and-expansion-redux"><a class="header" href="#metavariables-and-expansion-redux">Metavariables and Expansion Redux</a></h1>
<p>Once the parser begins consuming tokens for a metavariable, <em>it cannot stop or backtrack</em>. This means
that the second rule of the following macro <em>cannot ever match</em>, no matter what input is provided:</p>
<pre><code class="language-ignore">macro_rules! dead_rule {
    ($e:expr) =&gt; { ... };
    ($i:ident +) =&gt; { ... };
}
</code></pre>
<p>Consider what happens if this macro is invoked as <code>dead_rule!(x+)</code>. The interpreter will start at
the first rule, and attempt to parse the input as an expression. The first token <code>x</code> is valid as
an expression. The second token is <em>also</em> valid in an expression, forming a binary addition node.</p>
<p>At this point, given that there is no right-hand side of the addition, you might expect the parser
to give up and try the next rule. Instead, the parser will panic and abort the entire compilation,
citing a syntax error.</p>
<p>As such, it is important in general that you write macro rules from most-specific to least-specific.</p>
<p>To defend against future syntax changes altering the interpretation of macro input, <code>macro_rules!</code>
restricts what can follow various metavariables. The complete list, showing what may follow what
fragment specifier, as of Rust 1.46 is as follows:</p>
<ul>
<li><a href="macros/minutiae/./fragment-specifiers.html#stmt"><code>stmt</code></a> and <a href="macros/minutiae/./fragment-specifiers.html#expr"><code>expr</code></a>: <code>=&gt;</code>, <code>,</code>, or <code>;</code></li>
<li><a href="macros/minutiae/./fragment-specifiers.html#pat"><code>pat</code></a>: <code>=&gt;</code>, <code>,</code>, <code>=</code>, <code>|</code>, <code>if</code>, <code>in</code></li>
<li><a href="macros/minutiae/./fragment-specifiers.html#path"><code>path</code></a> and <a href="macros/minutiae/./fragment-specifiers.html#ty"><code>ty</code></a>:<code>=&gt;</code>, <code>,</code>, <code>=</code>, <code>|</code>, <code>;</code>, <code>:</code>, <code>&gt;</code>, <code>&gt;&gt;</code>, <code>[</code>, <code>{</code>, <code>as</code>, <code>where</code>, or a macro
variable of the <a href="macros/minutiae/./fragment-specifiers.html#block"><code>block</code></a> fragment specifier.</li>
<li><a href="macros/minutiae/./fragment-specifiers.html#vis"><code>vis</code></a>: <code>,</code>, an identifier other than a non-raw <code>priv</code>, any token that can begin a type or a
metavariable with an <a href="macros/minutiae/./fragment-specifiers.html#ident"><code>ident</code></a>, <a href="macros/minutiae/./fragment-specifiers.html#ty"><code>ty</code></a>, or <a href="macros/minutiae/./fragment-specifiers.html#path"><code>path</code></a> fragment specifier.</li>
<li>All other fragment specifiers have no restrictions.</li>
</ul>
<p>Repetitions also adhere to these restrictions, meaning if a repetition can repeat multiple times
(<code>*</code> or <code>+</code>), then the contents must be able to follow themselves. If a repetition can repeat zero
times (<code>?</code> or <code>*</code>) then what comes after the repetition must be able to follow what comes before.</p>
<p>The parser also does not perform any kind of lookahead. That means if the compiler cannot
unambiguously determine how to parse the macro invocation one token at a time, it will abort with an
ambiguity error. A simple example that triggers this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! ambiguity {
    ($($i:ident)* $i2:ident) =&gt; { };
}

// error:
//    local ambiguity: multiple parsing options: built-in NTs ident ('i') or ident ('i2').
ambiguity!(an_identifier);
<span class="boring">}
</span></code></pre></pre>
<p>The parser does not look ahead past the identifier to see if the following token is a <code>)</code>, which
would allow it to parse properly.</p>
<p>One aspect of substitution that often surprises people is that substitution is <em>not</em> token-based,
despite very much <em>looking</em> like it.</p>
<p>Consider the following:</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! capture_then_match_tokens {
    ($e:expr) =&gt; {match_tokens!($e)};
}

macro_rules! match_tokens {
    ($a:tt + $b:tt) =&gt; {&quot;got an addition&quot;};
    (($i:ident)) =&gt; {&quot;got an identifier&quot;};
    ($($other:tt)*) =&gt; {&quot;got something else&quot;};
}

fn main() {
    println!(&quot;{}\n{}\n{}\n&quot;,
        match_tokens!((caravan)),
        match_tokens!(3 + 6),
        match_tokens!(5));
    println!(&quot;{}\n{}\n{}&quot;,
        capture_then_match_tokens!((caravan)),
        capture_then_match_tokens!(3 + 6),
        capture_then_match_tokens!(5));
}
</code></pre></pre>
<p>The output is:</p>
<pre><code class="language-text">got an identifier
got an addition
got something else

got something else
got something else
got something else
</code></pre>
<p>By parsing the input into an AST node, the substituted result becomes <em>un-destructible</em>; <em>i.e.</em> you
cannot examine the contents or match against it ever again.</p>
<p>Here is <em>another</em> example which can be particularly confusing:</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! capture_then_what_is {
    (#[$m:meta]) =&gt; {what_is!(#[$m])};
}

macro_rules! what_is {
    (#[no_mangle]) =&gt; {&quot;no_mangle attribute&quot;};
    (#[inline]) =&gt; {&quot;inline attribute&quot;};
    ($($tts:tt)*) =&gt; {concat!(&quot;something else (&quot;, stringify!($($tts)*), &quot;)&quot;)};
}

fn main() {
    println!(
        &quot;{}\n{}\n{}\n{}&quot;,
        what_is!(#[no_mangle]),
        what_is!(#[inline]),
        capture_then_what_is!(#[no_mangle]),
        capture_then_what_is!(#[inline]),
    );
}
</code></pre></pre>
<p>The output is:</p>
<pre><code class="language-text">no_mangle attribute
inline attribute
something else (#[no_mangle])
something else (#[inline])
</code></pre>
<p>The only way to avoid this is to capture using the <a href="macros/minutiae/./fragment-specifiers.html#tt"><code>tt</code></a>, <a href="macros/minutiae/./fragment-specifiers.html#ident"><code>ident</code></a> or <a href="macros/minutiae/./fragment-specifiers.html#lifetime"><code>lifetime</code></a> kinds. Once you
capture with anything else, the only thing you can do with the result from then on is substitute it
directly into the output.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="hygiene"><a class="header" href="#hygiene">Hygiene</a></h1>
<p><code>macro_rules!</code> macros in Rust are <em>partially</em> hygienic. Specifically, they are hygienic when it
comes to most identifiers, but <em>not</em> when it comes to generic type parameters or lifetimes.</p>
<p>Hygiene works by attaching an invisible &quot;syntax context&quot; value to all identifiers. When two
identifiers are compared, <em>both</em> the identifiers' textual names <em>and</em> syntax contexts must be
identical for the two to be considered equal.</p>
<p>To illustrate this, consider the following code:</p>
<pre class="rust rust-example-rendered"><span class="synctx-0"><span class="macro">macro_rules</span><span class="macro">!</span> <span class="ident">using_a</span> {&#xa;    (<span class="macro-nonterminal">$</span><span class="macro-nonterminal">e</span>:<span class="ident">expr</span>) <span class="op">=&gt;</span> {&#xa;        {&#xa;            <span class="kw">let</span> <span class="ident">a</span> <span class="op">=</span> <span class="number">42</span>;&#xa;            <span class="macro-nonterminal">$</span><span class="macro-nonterminal">e</span>&#xa;        }&#xa;    }&#xa;}&#xa;&#xa;<span class="kw">let</span> <span class="ident">four</span> <span class="op">=</span> <span class="macro">using_a</span><span class="macro">!</span>(<span class="ident">a</span> <span class="op">/</span> <span class="number">10</span>);</span></pre>
<p>We will use the background colour to denote the syntax context. Now, let's expand the macro
invocation:</p>
<pre class="rust rust-example-rendered"><span class="synctx-0"><span class="kw">let</span> <span class="ident">four</span> <span class="op">=</span> </span><span class="synctx-1">{&#xa;    <span class="kw">let</span> <span class="ident">a</span> <span class="op">=</span> <span class="number">42</span>;&#xa;    </span><span class="synctx-0"><span class="ident">a</span> <span class="op">/</span> <span class="number">10</span></span><span class="synctx-1">&#xa;}</span><span class="synctx-0">;</span></pre>
<p>First, recall that <code>macro_rules!</code> invocations effectively <em>disappear</em> during expansion.</p>
<p>Second, if you attempt to compile this code, the compiler will respond with something along the
following lines:</p>
<pre><code class="language-text">error[E0425]: cannot find value `a` in this scope
  --&gt; src/main.rs:13:21
   |
13 | let four = using_a!(a / 10);
   |                     ^ not found in this scope
</code></pre>
<p>Note that the background colour (<em>i.e.</em> syntax context) for the expanded macro <em>changes</em> as part of
expansion. Each <code>macro_rules!</code> macro expansion is given a new, unique syntax context for its
contents. As a result, there are <em>two different <code>a</code>s</em> in the expanded code: one in the first syntax
context, the second in the other. In other words, <code><span class="synctx-0">a</span></code> is not
the same identifier as <code><span class="synctx-1">a</span></code>, however similar they may appear.</p>
<p>That said, tokens that were substituted <em>into</em> the expanded output <em>retain</em> their original syntax
context (by virtue of having been provided to the macro as opposed to being part of the macro itself).
Thus, the solution is to modify the macro as follows:</p>
<pre class="rust rust-example-rendered"><span class="synctx-0"><span class="macro">macro_rules</span><span class="macro">!</span> <span class="ident">using_a</span> {&#xa;    (<span class="macro-nonterminal">$</span><span class="macro-nonterminal">a</span>:<span class="ident">ident</span>, <span class="macro-nonterminal">$</span><span class="macro-nonterminal">e</span>:<span class="ident">expr</span>) <span class="op">=&gt;</span> {&#xa;        {&#xa;            <span class="kw">let</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">a</span> <span class="op">=</span> <span class="number">42</span>;&#xa;            <span class="macro-nonterminal">$</span><span class="macro-nonterminal">e</span>&#xa;        }&#xa;    }&#xa;}&#xa;&#xa;<span class="kw">let</span> <span class="ident">four</span> <span class="op">=</span> <span class="macro">using_a</span><span class="macro">!</span>(<span class="ident">a</span>, <span class="ident">a</span> <span class="op">/</span> <span class="number">10</span>);</span></pre>
<p>Which, upon expansion becomes:</p>
<pre class="rust rust-example-rendered"><span class="synctx-0"><span class="kw">let</span> <span class="ident">four</span> <span class="op">=</span> </span><span class="synctx-1">{&#xa;    <span class="kw">let</span> </span><span class="synctx-0"><span class="ident">a</span></span><span class="synctx-1"> <span class="op">=</span> <span class="number">42</span>;&#xa;    </span><span class="synctx-0"><span class="ident">a</span> <span class="op">/</span> <span class="number">10</span></span><span class="synctx-1">&#xa;}</span><span class="synctx-0">;</span></pre>
<p>The compiler will accept this code because there is only one <code>a</code> being used.</p>
<h3 id="crate"><a class="header" href="#crate"><code>$crate</code></a></h3>
<p>Hygiene is also the reason that we need the <code>$crate</code> metavariable when our macro needs access to
other items in the defining crate. What this special metavariable does is that it expands to an
absolute path to the defining crate.</p>
<pre><code class="language-rust ignore">//// Definitions in the `helper_macro` crate.
#[macro_export]
macro_rules! helped {
    // () =&gt; { helper!() } // This might lead to an error due to 'helper' not being in scope.
    () =&gt; { $crate::helper!() }
}

#[macro_export]
macro_rules! helper {
    () =&gt; { () }
}

//// Usage in another crate.
// Note that `helper_macro::helper` is not imported!
use helper_macro::helped;

fn unit() {
   // but it still works due to `$crate` properly expanding to the crate path `helper_macro`
   helped!();
}
</code></pre>
<p>Note that, because <code>$crate</code> refers to the current crate, it must be used with a fully qualified
module path when referring to non-macro items:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub mod inner {
    #[macro_export]
    macro_rules! call_foo {
        () =&gt; { $crate::inner::foo() };
    }

    pub fn foo() {}
}
<span class="boring">}
</span></code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="non-identifier-identifiers"><a class="header" href="#non-identifier-identifiers">Non-Identifier Identifiers</a></h1>
<p>There are two tokens which you are likely to run into eventually that <em>look</em> like identifiers,
but aren't. Except when they are.</p>
<p>First is <code>self</code>. This is <em>very definitely</em> a keyword. However, it also happens to fit the definition
of an identifier. In regular Rust code, there's no way for <code>self</code> to be interpreted as an identifier,
but it <em>can</em> happen with <code>macro_rules!</code> macros:</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! what_is {
    (self) =&gt; {&quot;the keyword `self`&quot;};
    ($i:ident) =&gt; {concat!(&quot;the identifier `&quot;, stringify!($i), &quot;`&quot;)};
}

macro_rules! call_with_ident {
    ($c:ident($i:ident)) =&gt; {$c!($i)};
}

fn main() {
    println!(&quot;{}&quot;, what_is!(self));
    println!(&quot;{}&quot;, call_with_ident!(what_is(self)));
}
</code></pre></pre>
<p>The above outputs:</p>
<pre><code class="language-text">the keyword `self`
the keyword `self`
</code></pre>
<p>But that makes no sense; <code>call_with_ident!</code> required an identifier, matched one, and substituted it!
So <code>self</code> is both a keyword and not a keyword at the same time. You might wonder how this is in any
way important. Take this example:</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! make_mutable {
    ($i:ident) =&gt; {let mut $i = $i;};
}

struct Dummy(i32);

impl Dummy {
    fn double(self) -&gt; Dummy {
        make_mutable!(self);
        self.0 *= 2;
        self
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;{:?}&quot;, Dummy(4).double().0);
</span><span class="boring">}
</span></code></pre></pre>
<p>This fails to compile with:</p>
<pre><code class="language-text">error: `mut` must be followed by a named binding
 --&gt; src/main.rs:2:24
  |
2 |     ($i:ident) =&gt; {let mut $i = $i;};
  |                        ^^^^^^ help: remove the `mut` prefix: `self`
...
9 |         make_mutable!(self);
  |         -------------------- in this macro invocation
  |
  = note: `mut` may be followed by `variable` and `variable @ pattern`
</code></pre>
<p>So the macro will happily match <code>self</code> as an identifier, allowing you to use it in cases where you
can't actually use it. But, fine; it somehow remembers that <code>self</code> is a keyword even when it's an
identifier, so you <em>should</em> be able to do this, right?</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! make_self_mutable {
    ($i:ident) =&gt; {let mut $i = self;};
}

struct Dummy(i32);

impl Dummy {
    fn double(self) -&gt; Dummy {
        make_self_mutable!(mut_self);
        mut_self.0 *= 2;
        mut_self
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;{:?}&quot;, Dummy(4).double().0);
</span><span class="boring">}
</span></code></pre></pre>
<p>This fails with:</p>
<pre><code class="language-text">error[E0424]: expected value, found module `self`
  --&gt; src/main.rs:2:33
   |
2  |       ($i:ident) =&gt; {let mut $i = self;};
   |                                   ^^^^ `self` value is a keyword only available in methods with a `self` parameter
...
8  | /     fn double(self) -&gt; Dummy {
9  | |         make_self_mutable!(mut_self);
   | |         ----------------------------- in this macro invocation
10 | |         mut_self.0 *= 2;
11 | |         mut_self
12 | |     }
   | |_____- this function has a `self` parameter, but a macro invocation can only access identifiers it receives from parameters
   |
</code></pre>
<p>Now the compiler thinks we refer to our module with <code>self</code>, but that doesn't make sense. We already
have a <code>self</code> right there, in the function signature which is definitely not a module. It's almost
like it's complaining that the <code>self</code> it's trying to use isn't the <em>same</em> <code>self</code>... as though the
<code>self</code> keyword has hygiene, like an... identifier.</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! double_method {
    ($body:expr) =&gt; {
        fn double(mut self) -&gt; Dummy {
            $body
        }
    };
}

struct Dummy(i32);

impl Dummy {
    double_method! {{
        self.0 *= 2;
        self
    }}
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;{:?}&quot;, Dummy(4).double().0);
</span><span class="boring">}
</span></code></pre></pre>
<p>Same error.  What about...</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! double_method {
    ($self_:ident, $body:expr) =&gt; {
        fn double(mut $self_) -&gt; Dummy {
            $body
        }
    };
}

struct Dummy(i32);

impl Dummy {
    double_method! {self, {
        self.0 *= 2;
        self
    }}
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;{:?}&quot;, Dummy(4).double().0);
</span><span class="boring">}
</span></code></pre></pre>
<p>At last, <em>this works</em>.  So <code>self</code> is both a keyword <em>and</em> an identifier when it feels like it.
Surely this works for other, similar constructs, right?</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! double_method {
    ($self_:ident, $body:expr) =&gt; {
        fn double($self_) -&gt; Dummy {
            $body
        }
    };
}

struct Dummy(i32);

impl Dummy {
    double_method! {_, 0}
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;{:?}&quot;, Dummy(4).double().0);
</span><span class="boring">}
</span></code></pre></pre>
<pre><code class="language-text">error: no rules expected the token `_`
  --&gt; src/main.rs:12:21
   |
1  | macro_rules! double_method {
   | -------------------------- when calling this macro
...
12 |     double_method! {_, 0}
   |                     ^ no rules expected this token in macro call
</code></pre>
<p>No, of course not.  <code>_</code> is a keyword that is valid in patterns and expressions, but somehow <em>isn't</em>
an identifier like the keyword <code>self</code> is, despite matching the definition of an identifier just the
same.</p>
<p>You might think you can get around this by using <code>$self_:pat</code> instead; that way, <code>_</code> will match!
Except, no, because <code>self</code> isn't a pattern. Joy.</p>
<p>The only work around for this (in cases where you want to accept some combination of these tokens)
is to use a <a href="macros/minutiae/./fragment-specifiers.html#tt"><code>tt</code></a> matcher instead.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="debugging"><a class="header" href="#debugging">Debugging</a></h1>
<p><code>rustc</code> provides a number of tools to debug <code>macro_rules!</code> macros. One of the most useful is
<a href="https://doc.rust-lang.org/std/macro.trace_macros.html"><code>trace_macros!</code></a>, which is a directive to the compiler instructing it to dump every <code>macro_rules!</code>
macro invocation prior to expansion. For example, given the following:</p>
<pre><code class="language-rust ignore"><span class="boring">// Note: make sure to use a nightly channel compiler.
</span>#![feature(trace_macros)]

macro_rules! each_tt {
    () =&gt; {};
    ($_tt:tt $($rest:tt)*) =&gt; {each_tt!($($rest)*);};
}

each_tt!(foo bar baz quux);
trace_macros!(true);
each_tt!(spim wak plee whum);
trace_macros!(false);
each_tt!(trom qlip winp xod);
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre>
<p>The output is:</p>
<pre><code class="language-text">note: trace_macro
  --&gt; src/main.rs:11:1
   |
11 | each_tt!(spim wak plee whum);
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: expanding `each_tt! { spim wak plee whum }`
   = note: to `each_tt ! (wak plee whum) ;`
   = note: expanding `each_tt! { wak plee whum }`
   = note: to `each_tt ! (plee whum) ;`
   = note: expanding `each_tt! { plee whum }`
   = note: to `each_tt ! (whum) ;`
   = note: expanding `each_tt! { whum }`
   = note: to `each_tt ! () ;`
   = note: expanding `each_tt! {  }`
   = note: to ``
</code></pre>
<p>This is <em>particularly</em> invaluable when debugging deeply recursive <code>macro_rules!</code> macros. You can
also enable this from the command-line by adding <code>-Z trace-macros</code> to the compiler command line.</p>
<p>Secondly, there is <a href="https://doc.rust-lang.org/std/macro.log_syntax.html"><code>log_syntax!</code></a> which causes the compiler to output all tokens passed to it. For
example, this makes the compiler sing a song:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">// Note: make sure to use a nightly channel compiler.
</span>#![feature(log_syntax)]

macro_rules! sing {
    () =&gt; {};
    ($tt:tt $($rest:tt)*) =&gt; {log_syntax!($tt); sing!($($rest)*);};
}

sing! {
    ^ &lt; @ &lt; . @ *
    '\x08' '{' '&quot;' _ # ' '
    - @ '$' &amp;&amp; / _ %
    ! ( '\t' @ | = &gt;
    ; '\x08' '\'' + '$' ? '\x7f'
    , # '&quot;' ~ | ) '\x07'
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>This can be used to do slightly more targeted debugging than <a href="https://doc.rust-lang.org/std/macro.trace_macros.html"><code>trace_macros!</code></a>.</p>
<p>Sometimes, it is what the macro <em>expands to</em> that proves problematic. For this, the <code>--pretty</code>
argument to the compiler can be used. Given the following code:</p>
<pre><code class="language-rust ignore">// Shorthand for initialising a `String`.
macro_rules! S {
    ($e:expr) =&gt; {String::from($e)};
}

fn main() {
    let world = S!(&quot;World&quot;);
    println!(&quot;Hello, {}!&quot;, world);
}
</code></pre>
<p>compiled with the following command:</p>
<pre><code class="language-shell">rustc -Z unstable-options --pretty expanded hello.rs
</code></pre>
<p>produces the following output (modified for formatting):</p>
<pre><code class="language-rust ignore">#![feature(no_std, prelude_import)]
#![no_std]
#[prelude_import]
use std::prelude::v1::*;
#[macro_use]
extern crate std as std;
// Shorthand for initialising a `String`.
fn main() {
    let world = String::from(&quot;World&quot;);
    ::std::io::_print(::std::fmt::Arguments::new_v1(
        {
            static __STATIC_FMTSTR: &amp;'static [&amp;'static str]
                = &amp;[&quot;Hello, &quot;, &quot;!\n&quot;];
            __STATIC_FMTSTR
        },
        &amp;match (&amp;world,) {
             (__arg0,) =&gt; [
                ::std::fmt::ArgumentV1::new(__arg0, ::std::fmt::Display::fmt)
            ],
        }
    ));
}
</code></pre>
<p>Other options to <code>--pretty</code> can be listed using <code>rustc -Z unstable-options --help -v</code>; a full list
is not provided since, as implied by the name, any such list would be subject to change at any time.</p>
<p>But not just <code>rustc</code> exposes means to aid in debugging macros. For the aforementioned
<code>--pretty=expanded</code> option, there exists a nice <code>cargo</code> addon called
<a href="https://github.com/dtolnay/cargo-expand"><code>cargo-expand</code></a> made by <a href="https://github.com/dtolnay"><code>dtolnay</code></a>
which is basically just a wrapper around it.</p>
<p>You can also use the <a href="https://play.rust-lang.org/">playground</a>, clicking on its <code>TOOLS</code> button in
the top right gives you the option to expand macros right there!</p>
<p>Another amazing tool is <a href="https://github.com/lukaslueg"><code>lukaslueg</code>'s</a>
<a href="https://github.com/lukaslueg/macro_railroad"><code>macro_railroad</code></a>, a tool that allows you visualize
and generate syntax diagrams for Rust's <code>macro_rules!</code> macros. It visualizes the accepted
macro's grammar as an automata. </p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="scoping"><a class="header" href="#scoping">Scoping</a></h1>
<p>The way in which function-like macros are scoped can be somewhat unintuitive. They use two forms
of scopes: textual scope, and path-based scope.</p>
<p>When such a macro is invoked by an unqualified identifier(an identifier that isn't part of a
mulit-part  path), it is first looked up in textual scoping and then in path-based scoping should
the first lookup not yield any results. If it is invoked by a qualified identifier it will skip the
textual scoping lookup and instead only do a look up in the path-based scoping.</p>
<h2 id="textual-scope"><a class="header" href="#textual-scope">Textual Scope</a></h2>
<p>Firstly, unlike everything else in the language, function-like macros will remain visible in
sub-modules.</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! X { () =&gt; {}; }
mod a {
    X!(); // defined
}
mod b {
    X!(); // defined
}
mod c {
    X!(); // defined
}
<span class="boring">fn main() {}
</span></code></pre></pre>
<blockquote>
<p><strong>Note</strong>: In these examples, remember that all of them have the <em>same behavior</em> when the module
contents are in separate files.</p>
</blockquote>
<p>Secondly, <em>also</em> unlike everything else in the language, <code>macro_rules!</code> macros are only accessible
<em>after</em> their definition. Also note that this example demonstrates how <code>macro_rules!</code> macros do not
&quot;leak&quot; out of their defining scope:</p>
<pre><pre class="playground"><code class="language-rust">mod a {
    // X!(); // undefined
}
mod b {
    // X!(); // undefined
    macro_rules! X { () =&gt; {}; }
    X!(); // defined
}
mod c {
    // X!(); // undefined
}
<span class="boring">fn main() {}
</span></code></pre></pre>
<p>To be clear, this lexical order dependency applies even if you move the macro to an outer scope:</p>
<pre><pre class="playground"><code class="language-rust">mod a {
    // X!(); // undefined
}
macro_rules! X { () =&gt; {}; }
mod b {
    X!(); // defined
}
mod c {
    X!(); // defined
}
<span class="boring">fn main() {}
</span></code></pre></pre>
<p>However, this dependency <em>does not</em> apply to macros themselves:</p>
<pre><pre class="playground"><code class="language-rust">mod a {
    // X!(); // undefined
}
macro_rules! X { () =&gt; { Y!(); }; }
mod b {
    // X!(); // defined, but Y! is undefined
}
macro_rules! Y { () =&gt; {}; }
mod c {
    X!(); // defined, and so is Y!
}
<span class="boring">fn main() {}
</span></code></pre></pre>
<p>Defining <code>macro_rules!</code> macros multiple times is allowed and the most recent declaration will simply
shadow previous ones unless it has gone out of scope.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! X { (1) =&gt; {}; }
X!(1);
macro_rules! X { (2) =&gt; {}; }
// X!(1); // Error: no rule matches `1`
X!(2);

mod a {
    macro_rules! X { (3) =&gt; {}; }
    // X!(2); // Error: no rule matches `2`
    X!(3);
}
// X!(3); // Error: no rule matches `3`
X!(2);

<span class="boring">}
</span></code></pre></pre>
<p><code>macro_rules!</code> macros can be exported from a module using the <code>#[macro_use]</code> attribute. Using this
on a module is similar to saying that you do not want to have the module's macro's scope end with
the module.</p>
<pre><pre class="playground"><code class="language-rust">mod a {
    // X!(); // undefined
}
#[macro_use]
mod b {
    macro_rules! X { () =&gt; {}; }
    X!(); // defined
}
mod c {
    X!(); // defined
}
<span class="boring">fn main() {}
</span></code></pre></pre>
<p>Note that this can interact in somewhat bizarre ways due to the fact that identifiers in a
<code>macro_rules!</code> macro (including other macros) are only resolved upon expansion:</p>
<pre><pre class="playground"><code class="language-rust">mod a {
    // X!(); // undefined
}
#[macro_use]
mod b {
    macro_rules! X { () =&gt; { Y!(); }; }
    // X!(); // defined, but Y! is undefined
}
macro_rules! Y { () =&gt; {}; }
mod c {
    X!(); // defined, and so is Y!
}
<span class="boring">fn main() {}
</span></code></pre></pre>
<p>Another complication is that <code>#[macro_use]</code> applied to an <code>extern crate</code> <em>does not</em> behave this way:
such declarations are effectively <em>hoisted</em> to the top of the module. Thus, assuming <code>X!</code> is defined
in an external crate called <code>mac</code>, the following holds:</p>
<pre><code class="language-rust ignore">mod a {
    // X!(); // defined, but Y! is undefined
}
macro_rules! Y { () =&gt; {}; }
mod b {
    X!(); // defined, and so is Y!
}
#[macro_use] extern crate macs;
mod c {
    X!(); // defined, and so is Y!
}
<span class="boring">fn main() {}
</span></code></pre>
<p>Finally, note that these scoping behaviors apply to <em>functions</em> as well, with the exception of
<code>#[macro_use]</code> (which isn't applicable):</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! X {
    () =&gt; { Y!() };
}

fn a() {
    macro_rules! Y { () =&gt; {&quot;Hi!&quot;} }
    assert_eq!(X!(), &quot;Hi!&quot;);
    {
        assert_eq!(X!(), &quot;Hi!&quot;);
        macro_rules! Y { () =&gt; {&quot;Bye!&quot;} }
        assert_eq!(X!(), &quot;Bye!&quot;);
    }
    assert_eq!(X!(), &quot;Hi!&quot;);
}

fn b() {
    macro_rules! Y { () =&gt; {&quot;One more&quot;} }
    assert_eq!(X!(), &quot;One more&quot;);
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    a();
</span><span class="boring">    b();
</span><span class="boring">}
</span></code></pre></pre>
<p>These scoping rules are why a common piece of advice is to place all <code>macro_rules!</code> macros which
should be accessible &quot;crate wide&quot; at the very top of your root module, before any other modules.
This ensures they are available <em>consistently</em>. This also applies to <code>mod</code> definitions for files, as
in:</p>
<pre><code class="language-rs">#[macro_use]
mod some_mod_that_defines_macros;
mod some_mod_that_uses_those_macros;
</code></pre>
<p>The order here is important, swap the declaration order and it won't compile.</p>
<h2 id="path-based-scope"><a class="header" href="#path-based-scope">Path-Based Scope</a></h2>
<p>By default, a <code>macro_rules!</code> macro has no path-based scope. However, if it has the <code>#[macro_export]</code>
attribute, then it is declared in the crate root scope and can be referred to similar to how you
refer to any other item. The <a href="macros/minutiae/./import-export.html">Import and Export</a> chapter goes more in-depth into said attribute.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="import-and-export"><a class="header" href="#import-and-export">Import and Export</a></h1>
<p>Importing <code>macro_rules!</code> macros differs between the two Rust Editions, 2015 and 2018. It is
recommended to read both parts nevertheless, as the 2018 Edition can still use the constructs that
are explained in the 2015 Edition.</p>
<h2 id="edition-2015"><a class="header" href="#edition-2015">Edition 2015</a></h2>
<p>In Edition 2015 you have to use the <code>#[macro_use]</code> attribute that has already been introduced in the
<a href="macros/minutiae/./scoping.html">scoping chapter</a>. This can be applied to <em>either</em> modules or external crates. For
example:</p>
<pre><pre class="playground"><code class="language-rust">#[macro_use]
mod macros {
    macro_rules! X { () =&gt; { Y!(); } }
    macro_rules! Y { () =&gt; {} }
}

X!();
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><code>macro_rules!</code> macros can be exported from the current crate using <code>#[macro_export]</code>. Note that this
<em>ignores</em> all visibility.</p>
<p>Given the following definition for a library package <code>macs</code>:</p>
<pre><code class="language-rust ignore">mod macros {
    #[macro_export] macro_rules! X { () =&gt; { Y!(); } }
    #[macro_export] macro_rules! Y { () =&gt; {} }
}

// X! and Y! are *not* defined here, but *are* exported,
// despite `macros` being private.
</code></pre>
<p>The following code will work as expected:</p>
<pre><code class="language-rust ignore">X!(); // X is defined
#[macro_use] extern crate macs;
X!();
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre>
<p>This works, as said in the <a href="macros/minutiae/./scoping.html">scoping chapter</a>, because <code>#[macro_use]</code> works slightly different on
extern crates, as it basically <em>hoists</em> the exported macros out of the crate to the top of the
module.</p>
<blockquote>
<p>Note: you can <em>only</em> <code>#[macro_use]</code> an external crate from the root module.</p>
</blockquote>
<p>Finally, when importing <code>macro_rules!</code> macros from an external crate, you can control <em>which</em> macros
you import. You can use this to limit namespace pollution, or to override specific macros, like so:</p>
<pre><code class="language-rust ignore">// Import *only* the `X!` macro.
#[macro_use(X)] extern crate macs;

// X!(); // X is defined, but Y! is undefined

macro_rules! Y { () =&gt; {} }

X!(); // X is defined, and so is Y!

fn main() {}
</code></pre>
<p>When exporting <code>macro_rules!</code> macros, it is often useful to refer to non-macro symbols in the
defining crate. Because crates can be renamed, there is a special substitution variable available:
<a href="macros/minutiae/./hygiene.html#crate"><code>$crate</code></a>. This will <em>always</em> expand to an absolute path prefix to the containing crate
(<em>e.g.</em> <code>:: macs</code>).</p>
<p>Note that unless your compiler version is &gt;= 1.30, this does <em>not</em> work for <code>macro_rules!</code> macros,
since <code>macro_rules!</code> macros do not interact with regular name resolution in any way. Otherwise, you
cannot use something like <code>$crate::Y!</code> to refer to a particular macro within your crate. The
implication, combined with selective imports via <code>#[macro_use]</code> is that there is currently <em>no way</em>
to guarantee any given macro will be available when imported by another crate.</p>
<p>It is recommended that you <em>always</em> use absolute paths to non-macro names, to avoid conflicts,
<em>including</em> names in the standard library.</p>
<h2 id="edition-2018"><a class="header" href="#edition-2018">Edition 2018</a></h2>
<p>The 2018 Edition made our lives a lot easier when it comes to <code>macro_rules!</code> macros. Why you ask?
Quite simply because it managed to make them feel more like proper items than some special thing in
the language. What this means is that we can properly import and use them in a namespaced fashion!</p>
<p>So instead of using <code>#[macro_use]</code> to import every exported macro from a crate into the global
namespace we can now do the following:</p>
<pre><code class="language-rs">use some_crate::some_macro;

fn main() {
    some_macro!(&quot;hello&quot;);
    // as well as
    some_crate::some_other_macro!(&quot;macro world&quot;);
}
</code></pre>
<p>Unfortunately, this only applies for external crates, if you use <code>macro_rules!</code> macros that you have
defined in your own crate you are still required to go with <code>#[macro_use]</code> on the defining modules.
So scoping applies there the same way as before as well.</p>
<blockquote>
<p>The <code>$crate</code> prefix works in this version for everything, macros and items alike since this Edition
came out with Rust 1.31.</p>
</blockquote>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="macros-a-practical-introduction"><a class="header" href="#macros-a-practical-introduction">Macros, A Practical Introduction</a></h1>
<p>This chapter will introduce the Rust macro-by-example system using a relatively simple, practical
example. It does <em>not</em> attempt to explain all of the intricacies of the system; its goal is to get
you comfortable with how and why macros are written.</p>
<p>There is also the <a href="https://doc.rust-lang.org/book/ch19-06-macros.html">Macros chapter of the Rust Book</a>
which is another high-level explanation, and the <a href="/macros.html">methodical introduction</a> chapter of
this book, which explains the macro system in detail.</p>
<h2 id="a-little-context"><a class="header" href="#a-little-context">A Little Context</a></h2>
<blockquote>
<p><strong>Note</strong>: don't panic! What follows is the only math that will be talked about. You can quite
safely skip this section if you just want to get to the meat of the article.</p>
</blockquote>
<p>If you aren't familiar, a recurrence relation is a sequence where each value is defined in terms of
one or more <em>previous</em> values, with one or more initial values to get the whole thing started. For
example, the <a href="https://en.wikipedia.org/wiki/Fibonacci_number">Fibonacci sequence</a> can be defined by
the relation:</p>
<p>\[ F_{n} = 0, 1, ..., F_{n-1} + F_{n-2}\]</p>
<p>Thus, the first two numbers in the sequence are 0 and 1, with the third being 
\( F_{0} + F_{1} = 0 + 1 = 1\), the fourth \( F_{1} + F_{2} = 1 + 1 = 2\), and so on forever.</p>
<p>Now, <em>because</em> such a sequence can go on forever, that makes defining a <code>fibonacci</code> function a
little tricky, since you obviously don't want to try returning a complete vector. What you <em>want</em> is
to return something which will lazily compute elements of the sequence as needed.</p>
<p>In Rust, that means producing an <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html"><code>Iterator</code></a>. This is not especially <em>hard</em>, but there is a fair
amount of boilerplate involved: you need to define a custom type, work out what state needs to be
stored in it, then implement the <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html"><code>Iterator</code></a> trait for it.</p>
<p>However, recurrence relations are simple enough that almost all of these details can be abstracted
out with a little macro-based code generation.</p>
<p>So, with all that having been said, let's get started.</p>
<h2 id="construction"><a class="header" href="#construction">Construction</a></h2>
<p>Usually, when working on a new macro, the first thing I do is decide what the macro invocation
should look like. In this specific case, my first attempt looked like this:</p>
<pre><code class="language-rust ignore">let fib = recurrence![a[n] = 0, 1, ..., a[n-1] + a[n-2]];

for e in fib.take(10) { println!(&quot;{}&quot;, e) }
</code></pre>
<p>From that, we can take a stab at how the macro should be defined, even if we aren't sure of the
actual expansion. This is useful because if you can't figure out how to parse the input syntax, then
<em>maybe</em> you need to change it.</p>
<pre><code class="language-rust ignore">macro_rules! recurrence {
    ( a[n] = $($inits:expr),+ , ... , $recur:expr ) =&gt; { /* ... */ };
}
<span class="boring">fn main() {}
</span></code></pre>
<p>Assuming you aren't familiar with the syntax, allow me to elucidate. This is defining a macro, using
the <a href="/macros/macro_rules.html"><code>macro_rules!</code></a> system, called <code>recurrence!</code>. This macro has a single parsing rule. That rule
says the input to the macro must match:</p>
<ul>
<li>the literal token sequence <code>a</code> <code>[</code> <code>n</code> <code>]</code> <code>=</code>,</li>
<li>a <a href="/macros/macro_rules.html#repetitions">repeating</a> (the <code>$( ... )</code>) sequence, using <code>,</code> as a separator, and one or more (<code>+</code>) repeats of:
<ul>
<li>a valid <em>expression</em> captured into the <a href="/macros/macro_rules.html#metavariables">metavariable</a> <code>inits</code> (<code>$inits:expr</code>)</li>
</ul>
</li>
<li>the literal token sequence <code>,</code> <code>...</code> <code>,</code>,</li>
<li>a valid <em>expression</em> captured into the <a href="/macros/macro_rules.html#metavariables">metavariable</a> <code>recur</code> (<code>$recur:expr</code>).</li>
</ul>
<p>Finally, the rule says that <em>if</em> the input matches this rule, then the macro invocation should be
replaced by the token sequence <code>/* ... */</code>.</p>
<p>It's worth noting that <code>inits</code>, as implied by the name, actually contains <em>all</em> the expressions that
match in this position, not just the first or last. What's more, it captures them <em>as a sequence</em> as
opposed to, say, irreversibly pasting them all together. Also note that you can do &quot;zero or more&quot;
with a repetition by using <code>*</code> instead of <code>+</code> and even optional, &quot;zero or one&quot; with <code>?</code>. There is no
support for &quot;zero or one&quot; or more specific numbers of repetitions.</p>
<p>As an exercise, let's take the proposed input and feed it through the rule, to see how it is
processed. The &quot;Position&quot; column will show which part of the syntax pattern needs to be matched
against next, denoted by a &quot;âŒ‚&quot;. Note that in some cases, there might be more than one possible
&quot;next&quot; element to match against. &quot;Input&quot; will contain all of the tokens that have <em>not</em> been
consumed yet. <code>inits</code> and <code>recur</code> will contain the contents of those bindings.</p>
<style type="text/css">
    /* Customisations. */

    .small-code code {
        font-size: 70%;
    }

    table.parse-table code {
        white-space: pre-wrap;
        background-color: transparent;
        border: none;
    }

    table.parse-table tbody>tr>td:nth-child(1)>code:nth-of-type(2) {
        color: red;
        margin-top: -0.7em;
        margin-bottom: -0.6em;
    }

    table.parse-table tbody>tr>td:nth-child(1)>code {
        display: block;
    }

    table.parse-table tbody>tr>td:nth-child(2)>code {
        display: block;
    }
</style>
<table class="parse-table">
    <colgroup>
        <col width="42%" />
        <col width="36%" />
        <col width="0%" />
        <col width="12%" />
    </colgroup>
    <thead>
        <tr>
            <th>Position</th>
            <th>Input</th>
            <th><code>inits</code></th>
            <th><code>recur</code></th>
        </tr>
    </thead>
    <tbody class="small-code">
        <tr>
            <td><code>a[n] = $($inits:expr),+ , ... , $recur:expr</code>
                <code>âŒ‚</code></td>
            <td><code>a[n] = 0, 1, ..., a[n-1] + a[n-2]</code></td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td><code>a[n] = $($inits:expr),+ , ... , $recur:expr</code>
                <code> âŒ‚</code></td>
            <td><code>[n] = 0, 1, ..., a[n-1] + a[n-2]</code></td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td><code>a[n] = $($inits:expr),+ , ... , $recur:expr</code>
                <code>  âŒ‚</code></td>
            <td><code>n] = 0, 1, ..., a[n-1] + a[n-2]</code></td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td><code>a[n] = $($inits:expr),+ , ... , $recur:expr</code>
                <code>   âŒ‚</code></td>
            <td><code>] = 0, 1, ..., a[n-1] + a[n-2]</code></td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td><code>a[n] = $($inits:expr),+ , ... , $recur:expr</code>
                <code>     âŒ‚</code></td>
            <td><code>= 0, 1, ..., a[n-1] + a[n-2]</code></td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td><code>a[n] = $($inits:expr),+ , ... , $recur:expr</code>
                <code>       âŒ‚</code></td>
            <td><code>0, 1, ..., a[n-1] + a[n-2]</code></td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td><code>a[n] = $($inits:expr),+ , ... , $recur:expr</code>
                <code>         âŒ‚</code></td>
            <td><code>0, 1, ..., a[n-1] + a[n-2]</code></td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td><code>a[n] = $($inits:expr),+ , ... , $recur:expr</code>
                <code>                     âŒ‚  âŒ‚</code></td>
            <td><code>, 1, ..., a[n-1] + a[n-2]</code></td>
            <td><code>0</code></td>
            <td></td>
        </tr>
        <tr>
            <td colspan="4" style="font-size:.8em;">
                <em>Note</em>: there are two âŒ‚ here, because the next input token might match <em>either</em> the comma
                separator <em>between</em>em> elements in the repetition, <em>or</em> the comma <em>after</em> the
                repetition. The macro system will keep track of both possibilities, until it is able to decide which one
                to follow.
            </td>
        </tr>
        <tr>
            <td><code>a[n] = $($inits:expr),+ , ... , $recur:expr</code>
                <code>         âŒ‚                âŒ‚</code></td>
            <td><code>1, ..., a[n-1] + a[n-2]</code></td>
            <td><code>0</code></td>
            <td></td>
        </tr>
        <tr>
            <td><code>a[n] = $($inits:expr),+ , ... , $recur:expr</code>
                <code>                     âŒ‚  âŒ‚ <s>âŒ‚</s></code></td>
            <td><code>, ..., a[n-1] + a[n-2]</code></td>
            <td><code>0</code>, <code>1</code></td>
            <td></td>
        </tr>
        <tr>
            <td colspan="4" style="font-size:.8em;">
                <em>Note</em>: the third, crossed-out marker indicates that the macro system has, as a consequence of
                the last token consumed, eliminated one of the previous possible branches.
            </td>
        </tr>
        <tr>
            <td><code>a[n] = $($inits:expr),+ , ... , $recur:expr</code>
                <code>         âŒ‚                âŒ‚</code></td>
            <td><code>..., a[n-1] + a[n-2]</code></td>
            <td><code>0</code>, <code>1</code></td>
            <td></td>
        </tr>
        <tr>
            <td><code>a[n] = $($inits:expr),+ , ... , $recur:expr</code>
                <code>         <s>âŒ‚</s>                    âŒ‚</code></td>
            <td><code>, a[n-1] + a[n-2]</code></td>
            <td><code>0</code>, <code>1</code></td>
            <td></td>
        </tr>
        <tr>
            <td><code>a[n] = $($inits:expr),+ , ... , $recur:expr</code>
                <code>                                âŒ‚</code></td>
            <td><code>a[n-1] + a[n-2]</code></td>
            <td><code>0</code>, <code>1</code></td>
            <td></td>
        </tr>
        <tr>
            <td><code>a[n] = $($inits:expr),+ , ... , $recur:expr</code>
                <code>                                           âŒ‚</code></td>
            <td></td>
            <td><code>0</code>, <code>1</code></td>
            <td><code>a[n-1] + a[n-2]</code></td>
        </tr>
        <tr>
            <td colspan="4" style="font-size:.8em;">
                <em>Note</em>: this particular step should make it clear that a binding like <tt>$recur:expr</tt> will
                consume an <em>entire expression</em>, using the compiler's knowledge of what constitutes a valid
                expression. As will be noted later, you can do this for other language constructs, too.
            </td>
        </tr>
    </tbody>
</table>
<p>The key take-away from this is that the macro system will <em>try</em> to incrementally match the tokens
provided as input to the macro against the provided rules. We'll come back to the &quot;try&quot; part.</p>
<p>Now, let's begin writing the final, fully expanded form. For this expansion, I was looking for
something like:</p>
<pre><code class="language-rust ignore">let fib = {
    struct Recurrence {
        mem: [u64; 2],
        pos: usize,
    }
</code></pre>
<p>This will be the actual iterator type. <code>mem</code> will be the memo buffer to hold the last few values so
the recurrence can be computed. <code>pos</code> is to keep track of the value of <code>n</code>.</p>
<blockquote>
<p><strong>Aside</strong>: I've chosen <code>u64</code> as a &quot;sufficiently large&quot; type for the elements of this sequence.
Don't worry about how this will work out for <em>other</em> sequences; we'll come to it.</p>
</blockquote>
<pre><code class="language-rust ignore">    impl Iterator for Recurrence {
        type Item = u64;

        #[inline]
        fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
            if self.pos &lt; 2 {
                let next_val = self.mem[self.pos];
                self.pos += 1;
                Some(next_val)
</code></pre>
<p>We need a branch to yield the initial values of the sequence; nothing tricky.</p>
<pre><code class="language-rust ignore">            } else {
                let a = /* something */;
                let n = self.pos;
                let next_val = a[n-1] + a[n-2];

                self.mem.TODO_shuffle_down_and_append(next_val);

                self.pos += 1;
                Some(next_val)
            }
        }
    }
</code></pre>
<p>This is a bit harder; we'll come back and look at <em>how</em> exactly to define <code>a</code>. Also,
<code>TODO_shuffle_down_and_append</code> is another placeholder; I want something that places <code>next_val</code> on
the end of the array, shuffling the rest down by one space, dropping the 0th element.</p>
<pre><code class="language-rust ignore">
    Recurrence { mem: [0, 1], pos: 0 }
};

for e in fib.take(10) { println!(&quot;{}&quot;, e) }
</code></pre>
<p>Lastly, return an instance of our new structure, which can then be iterated over. To summarise, the
complete expansion is:</p>
<pre><code class="language-rust ignore">let fib = {
    struct Recurrence {
        mem: [u64; 2],
        pos: usize,
    }

    impl Iterator for Recurrence {
        type Item = u64;

        #[inline]
        fn next(&amp;mut self) -&gt; Option&lt;u64&gt; {
            if self.pos &lt; 2 {
                let next_val = self.mem[self.pos];
                self.pos += 1;
                Some(next_val)
            } else {
                let a = /* something */;
                let n = self.pos;
                let next_val = (a[n-1] + a[n-2]);

                self.mem.TODO_shuffle_down_and_append(next_val.clone());

                self.pos += 1;
                Some(next_val)
            }
        }
    }

    Recurrence { mem: [0, 1], pos: 0 }
};

for e in fib.take(10) { println!(&quot;{}&quot;, e) }
</code></pre>
<blockquote>
<p><strong>Aside</strong>: Yes, this <em>does</em> mean we're defining a different <code>Recurrence</code> struct and its
implementation for each macro invocation. Most of this will optimise away in the final binary,
with some judicious use of <code>#[inline]</code> attributes.</p>
</blockquote>
<p>It's also useful to check your expansion as you're writing it. If you see anything in the expansion
that needs to vary with the invocation, but <em>isn't</em> in the actual macro syntax, you should work out
where to introduce it. In this case, we've added <code>u64</code>, but that's not neccesarily what the user
wants, nor is it in the macro syntax. So let's fix that.</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! recurrence {
    ( a[n]: $sty:ty = $($inits:expr),+ , ... , $recur:expr ) =&gt; { /* ... */ };
}

/*
let fib = recurrence![a[n]: u64 = 0, 1, ..., a[n-1] + a[n-2]];

for e in fib.take(10) { println!(&quot;{}&quot;, e) }
*/
<span class="boring">fn main() {}
</span></code></pre></pre>
<p>Here, I've added a new metavariable: <code>sty</code> which should be a type.</p>
<blockquote>
<p><strong>Aside</strong>: if you're wondering, the bit after the colon in a metavariable can be one of several
kinds of syntax matchers. The most common ones are <code>item</code>, <code>expr</code>, and <code>ty</code>. A complete
explanation can be found in <a href="/macros/macro_rules.html#Metavariables">Macros, A Methodical Introduction; <code>macro_rules!</code> (Matchers)</a>.</p>
<p>There's one other thing to be aware of: in the interests of future-proofing the language, the
compiler restricts what tokens you're allowed to put <em>after</em> a matcher, depending on what kind
it is. Typically, this comes up when trying to match expressions or statements; those can
<em>only</em> be followed by one of <code>=&gt;</code>, <code>,</code>, and <code>;</code>.</p>
<p>A complete list can be found in
<a href="/macros/minutiae/metavar-and-expansion.html">Macros, A Methodical Introduction; Minutiae; Metavariables and Expansion Redux</a>.</p>
</blockquote>
<h2 id="indexing-and-shuffling"><a class="header" href="#indexing-and-shuffling">Indexing and Shuffling</a></h2>
<p>I will skim a bit over this part, since it's effectively tangential to the macro stuff. We want to
make it so that the user can access previous values in the sequence by indexing <code>a</code>; we want it to
act as a sliding window keeping the last few (in this case, 2) elements of the sequence.</p>
<p>We can do this pretty easily with a wrapper type:</p>
<pre><code class="language-rust ignore">struct IndexOffset&lt;'a&gt; {
    slice: &amp;'a [u64; 2],
    offset: usize,
}

impl&lt;'a&gt; Index&lt;usize&gt; for IndexOffset&lt;'a&gt; {
    type Output = u64;

    #[inline(always)]
    fn index&lt;'b&gt;(&amp;'b self, index: usize) -&gt; &amp;'b u64 {
        use std::num::Wrapping;

        let index = Wrapping(index);
        let offset = Wrapping(self.offset);
        let window = Wrapping(2);

        let real_index = index - offset + window;
        &amp;self.slice[real_index.0]
    }
}
</code></pre>
<blockquote>
<p><strong>Aside</strong>: since lifetimes come up <em>a lot</em> with people new to Rust, a quick explanation: <code>'a</code> and
<code>'b</code> are lifetime parameters that are used to track where a reference
(<em>i.e.</em> a borrowed pointer to some data) is valid. In this case, <code>IndexOffset</code> borrows a
reference to our iterator's data, so it needs to keep track of how long it's allowed to hold
that reference for, using <code>'a</code>.</p>
<p><code>'b</code> is used because the <code>Index::index</code> function (which is how subscript syntax is actually
implemented) is <em>also</em> parameterised on a lifetime, on account of returning a borrowed reference.
<code>'a</code> and <code>'b</code> are not necessarily the same thing in all cases. The borrow checker will make sure
that even though we don't explicitly relate <code>'a</code> and <code>'b</code> to one another, we don't accidentally
violate memory safety.</p>
</blockquote>
<p>This changes the definition of <code>a</code> to:</p>
<pre><code class="language-rust ignore">let a = IndexOffset { slice: &amp;self.mem, offset: n };
</code></pre>
<p>The only remaining question is what to do about <code>TODO_shuffle_down_and_append</code>. I wasn't able to
find a method in the standard library with exactly the semantics I wanted, but it isn't hard to do
by hand.</p>
<pre><code class="language-rust ignore">{
    use std::mem::swap;

    let mut swap_tmp = next_val;
    for i in (0..2).rev() {
        swap(&amp;mut swap_tmp, &amp;mut self.mem[i]);
    }
}
</code></pre>
<p>This swaps the new value into the end of the array, swapping the other elements down one space.</p>
<blockquote>
<p><strong>Aside</strong>: doing it this way means that this code will work for non-copyable types, as well.</p>
</blockquote>
<p>The working code thus far now looks like this:</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! recurrence {
    ( a[n]: $sty:ty = $($inits:expr),+ , ... , $recur:expr ) =&gt; { /* ... */ };
}

fn main() {
    /*
    let fib = recurrence![a[n]: u64 = 0, 1, ..., a[n-1] + a[n-2]];

    for e in fib.take(10) { println!(&quot;{}&quot;, e) }
    */
    let fib = {
        use std::ops::Index;

        struct Recurrence {
            mem: [u64; 2],
            pos: usize,
        }

        struct IndexOffset&lt;'a&gt; {
            slice: &amp;'a [u64; 2],
            offset: usize,
        }

        impl&lt;'a&gt; Index&lt;usize&gt; for IndexOffset&lt;'a&gt; {
            type Output = u64;

            #[inline(always)]
            fn index&lt;'b&gt;(&amp;'b self, index: usize) -&gt; &amp;'b u64 {
                use std::num::Wrapping;

                let index = Wrapping(index);
                let offset = Wrapping(self.offset);
                let window = Wrapping(2);

                let real_index = index - offset + window;
                &amp;self.slice[real_index.0]
            }
        }

        impl Iterator for Recurrence {
            type Item = u64;

            #[inline]
            fn next(&amp;mut self) -&gt; Option&lt;u64&gt; {
                if self.pos &lt; 2 {
                    let next_val = self.mem[self.pos];
                    self.pos += 1;
                    Some(next_val)
                } else {
                    let next_val = {
                        let n = self.pos;
                        let a = IndexOffset { slice: &amp;self.mem, offset: n };
                        (a[n-1] + a[n-2])
                    };

                    {
                        use std::mem::swap;

                        let mut swap_tmp = next_val;
                        for i in (0..2).rev() {
                            swap(&amp;mut swap_tmp, &amp;mut self.mem[i]);
                        }
                    }

                    self.pos += 1;
                    Some(next_val)
                }
            }
        }

        Recurrence { mem: [0, 1], pos: 0 }
    };

    for e in fib.take(10) { println!(&quot;{}&quot;, e) }
}
</code></pre></pre>
<p>Note that I've changed the order of the declarations of <code>n</code> and <code>a</code>, as well as wrapped them
(along with the recurrence expression) in a block. The reason for the first should be obvious
(<code>n</code> needs to be defined first so I can use it for <code>a</code>). The reason for the second is that the
borrowed reference <code>&amp;self.mem</code> will prevent the swaps later on from happening (you cannot mutate
something that is aliased elsewhere). The block ensures that the <code>&amp;self.mem</code> borrow expires before
then.</p>
<p>Incidentally, the only reason the code that does the <code>mem</code> swaps is in a block is to narrow the
scope in which <code>std::mem::swap</code> is available, for the sake of being tidy.</p>
<p>If we take this code and run it, we get:</p>
<pre><code class="language-text">0
1
2
3
5
8
13
21
34
</code></pre>
<p>Success! Now, let's copy &amp; paste this into the macro expansion, and replace the expanded code with
an invocation. This gives us:</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! recurrence {
    ( a[n]: $sty:ty = $($inits:expr),+ , ... , $recur:expr ) =&gt; {
        {
            /*
                What follows here is *literally* the code from before,
                cut and pasted into a new position. No other changes
                have been made.
            */

            use std::ops::Index;

            struct Recurrence {
                mem: [u64; 2],
                pos: usize,
            }

            struct IndexOffset&lt;'a&gt; {
                slice: &amp;'a [u64; 2],
                offset: usize,
            }

            impl&lt;'a&gt; Index&lt;usize&gt; for IndexOffset&lt;'a&gt; {
                type Output = u64;

                #[inline(always)]
                fn index&lt;'b&gt;(&amp;'b self, index: usize) -&gt; &amp;'b u64 {
                    use std::num::Wrapping;

                    let index = Wrapping(index);
                    let offset = Wrapping(self.offset);
                    let window = Wrapping(2);

                    let real_index = index - offset + window;
                    &amp;self.slice[real_index.0]
                }
            }

            impl Iterator for Recurrence {
                type Item = u64;

                #[inline]
                fn next(&amp;mut self) -&gt; Option&lt;u64&gt; {
                    if self.pos &lt; 2 {
                        let next_val = self.mem[self.pos];
                        self.pos += 1;
                        Some(next_val)
                    } else {
                        let next_val = {
                            let n = self.pos;
                            let a = IndexOffset { slice: &amp;self.mem, offset: n };
                            (a[n-1] + a[n-2])
                        };

                        {
                            use std::mem::swap;

                            let mut swap_tmp = next_val;
                            for i in (0..2).rev() {
                                swap(&amp;mut swap_tmp, &amp;mut self.mem[i]);
                            }
                        }

                        self.pos += 1;
                        Some(next_val)
                    }
                }
            }

            Recurrence { mem: [0, 1], pos: 0 }
        }
    };
}

fn main() {
    let fib = recurrence![a[n]: u64 = 0, 1, ..., a[n-1] + a[n-2]];

    for e in fib.take(10) { println!(&quot;{}&quot;, e) }
}
</code></pre></pre>
<p>Obviously, we aren't <em>using</em> the metavariables yet, but we can change that fairly easily. However,
if we try to compile this, <code>rustc</code> aborts, telling us:</p>
<pre><code class="language-text">error: local ambiguity: multiple parsing options: built-in NTs expr ('inits') or 1 other option.
  --&gt; src/main.rs:75:45
   |
75 |     let fib = recurrence![a[n]: u64 = 0, 1, ..., a[n-1] + a[n-2]];
   |              
</code></pre>
<p>Here, we've run into a limitation of <code>macro_rules</code>. The problem is that second comma. When it sees
it during expansion, <code>macro_rules</code> can't decide if it's supposed to parse <em>another</em> expression for
<code>inits</code>, or <code>...</code>.  Sadly, it isn't quite clever enough to realise that <code>...</code> isn't a valid
expression, so it gives up. Theoretically, this <em>should</em> work as desired, but currently doesn't.</p>
<blockquote>
<p><strong>Aside</strong>: I <em>did</em> fib a little about how our rule would be interpreted by the macro system. In
general, it <em>should</em> work as described, but doesn't in this case. The <code>macro_rules</code> machinery,
as it stands, has its foibles, and its worthwhile remembering that on occasion, you'll need to
contort a little to get it to work.</p>
<p>In this <em>particular</em> case, there are two issues. First, the macro system doesn't know what does
and does not constitute the various grammar elements (<em>e.g.</em> an expression); that's the parser's
job. As such, it doesn't know that <code>...</code> isn't an expression. Secondly, it has no way of trying
to capture a compound grammar element (like an expression) without 100% committing to that
capture.</p>
<p>In other words, it can ask the parser to try and parse some input as an expression, but the parser
will respond to any problems by aborting. The only way the macro system can currently deal with
this is to just try to forbid situations where this could be a problem.</p>
<p>On the bright side, this is a state of affairs that exactly <em>no one</em> is enthusiastic about. The
<code>macro</code> keyword has already been reserved for a more rigorously-defined future macro system.
Until then, needs must.</p>
</blockquote>
<p>Thankfully, the fix is relatively simple: we remove the comma from the syntax. To keep things
balanced, we'll remove <em>both</em> commas around <code>...</code>:</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! recurrence {
    ( a[n]: $sty:ty = $($inits:expr),+ ... $recur:expr ) =&gt; {
//                                     ^~~ changed
        /* ... */
<span class="boring">        // Cheat :D
</span><span class="boring">        (vec![0u64, 1, 2, 3, 5, 8, 13, 21, 34]).into_iter()
</span>    };
}

fn main() {
    let fib = recurrence![a[n]: u64 = 0, 1 ... a[n-1] + a[n-2]];
//                                         ^~~ changed

    for e in fib.take(10) { println!(&quot;{}&quot;, e) }
}
</code></pre></pre>
<p>Success! ... or so I thought. Turns out this is being rejected by the compiler nowadays, while it
was fine back when this was written. The reason for this is that the compiler now recognizes the
<code>...</code> as a token, and as we know we may only use <code>=&gt;</code>, <code>,</code> or <code>;</code> after an expression fragment. So
unfortunately we are now out of luck as our dreamed up syntax will not work out this way, so let us
just choose one that looks the most befitting that we are allowed to use instead,
I'd say replacing <code>,</code> with <code>;</code> works.</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! recurrence {
    ( a[n]: $sty:ty = $($inits:expr),+ ; ... ; $recur:expr ) =&gt; {
//                                     ^~~~~~^ changed
        /* ... */
<span class="boring">        // Cheat :D
</span><span class="boring">        (vec![0u64, 1, 2, 3, 5, 8, 13, 21, 34]).into_iter()
</span>    };
}

fn main() {
    let fib = recurrence![a[n]: u64 = 0, 1; ...; a[n-1] + a[n-2]];
//                                        ^~~~~^ changed

    for e in fib.take(10) { println!(&quot;{}&quot;, e) }
}
</code></pre></pre>
<p>Success! But for real this time.</p>
<h3 id="substitution"><a class="header" href="#substitution">Substitution</a></h3>
<p>Substituting something you've captured in a macro is quite simple; you can insert the contents of a
metavariable <code>$sty:ty</code> by using <code>$sty</code>. So, let's go through and fix the <code>u64</code>s:</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! recurrence {
    ( a[n]: $sty:ty = $($inits:expr),+ ; ... ; $recur:expr ) =&gt; {
        {
            use std::ops::Index;

            struct Recurrence {
                mem: [$sty; 2],
//                    ^~~~ changed
                pos: usize,
            }

            struct IndexOffset&lt;'a&gt; {
                slice: &amp;'a [$sty; 2],
//                          ^~~~ changed
                offset: usize,
            }

            impl&lt;'a&gt; Index&lt;usize&gt; for IndexOffset&lt;'a&gt; {
                type Output = $sty;
//                            ^~~~ changed

                #[inline(always)]
                fn index&lt;'b&gt;(&amp;'b self, index: usize) -&gt; &amp;'b $sty {
//                                                          ^~~~ changed
                    use std::num::Wrapping;

                    let index = Wrapping(index);
                    let offset = Wrapping(self.offset);
                    let window = Wrapping(2);

                    let real_index = index - offset + window;
                    &amp;self.slice[real_index.0]
                }
            }

            impl Iterator for Recurrence {
                type Item = $sty;
//                          ^~~~ changed

                #[inline]
                fn next(&amp;mut self) -&gt; Option&lt;$sty&gt; {
//                                           ^~~~ changed
                    /* ... */
<span class="boring">                    if self.pos &lt; 2 {
</span><span class="boring">                        let next_val = self.mem[self.pos];
</span><span class="boring">                        self.pos += 1;
</span><span class="boring">                        Some(next_val)
</span><span class="boring">                    } else {
</span><span class="boring">                        let next_val = {
</span><span class="boring">                            let n = self.pos;
</span><span class="boring">                            let a = IndexOffset { slice: &amp;self.mem, offset: n };
</span><span class="boring">                            (a[n-1] + a[n-2])
</span><span class="boring">                        };
</span><span class="boring">    
</span><span class="boring">                        {
</span><span class="boring">                            use std::mem::swap;
</span><span class="boring">    
</span><span class="boring">                            let mut swap_tmp = next_val;
</span><span class="boring">                            for i in (0..2).rev() {
</span><span class="boring">                                swap(&amp;mut swap_tmp, &amp;mut self.mem[i]);
</span><span class="boring">                            }
</span><span class="boring">                        }
</span><span class="boring">    
</span><span class="boring">                        self.pos += 1;
</span><span class="boring">                        Some(next_val)
</span><span class="boring">                    }
</span>                }
            }

            Recurrence { mem: [0, 1], pos: 0 }
        }
    };
}

fn main() {
    let fib = recurrence![a[n]: u64 = 0, 1; ...; a[n-1] + a[n-2]];

    for e in fib.take(10) { println!(&quot;{}&quot;, e) }
}
</code></pre></pre>
<p>Let's tackle a harder one: how to turn <code>inits</code> into both the array literal <code>[0, 1]</code> <em>and</em> the array
type, <code>[$sty; 2]</code>. The first one we can do like so:</p>
<pre><code class="language-rust ignore">            Recurrence { mem: [$($inits),+], pos: 0 }
//                             ^~~~~~~~~~~ changed
</code></pre>
<p>This effectively does the opposite of the capture: repeat <code>inits</code> one or more times, separating each
with a comma. This expands to the expected sequence of tokens: <code>0, 1</code>.</p>
<p>Somehow turning <code>inits</code> into a literal <code>2</code> is a little trickier. It turns out that there's no direct
way to do this, but we <em>can</em> do it by using a second macro. Let's take this one step at a time.</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! count_exprs {
    /* ??? */
<span class="boring">    () =&gt; {}
</span>}
<span class="boring">fn main() {}
</span></code></pre></pre>
<p>The obvious case is: given zero expressions, you would expect <code>count_exprs</code> to expand to a literal
<code>0</code>.</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! count_exprs {
    () =&gt; (0);
//  ^~~~~~~~~~ added
}
<span class="boring">fn main() {
</span><span class="boring">    const _0: usize = count_exprs!();
</span><span class="boring">    assert_eq!(_0, 0);
</span><span class="boring">}
</span></code></pre></pre>
<blockquote>
<p><strong>Aside</strong>: You may have noticed I used parentheses here instead of curly braces for the expansion.
<code>macro_rules</code> really doesn't care <em>what</em> you use, so long as it's one of the &quot;matcher&quot; pairs:
<code>( )</code>, <code>{ }</code> or <code>[ ]</code>. In fact, you can switch out the matchers on the macro itself
(<em>i.e.</em> the matchers right after the macro name), the matchers around the syntax rule, and the
matchers around the corresponding expansion.</p>
<p>You can also switch out the matchers used when you <em>invoke</em> a macro, but in a more limited fashion:
a macro invoked as <code>{ ... }</code> or <code>( ... );</code> will <em>always</em> be parsed as an <em>item</em> (<em>i.e.</em> like a
<code>struct</code> or <code>fn</code> declaration).  This is important when using macros in a function body; it helps
disambiguate between &quot;parse like an expression&quot; and &quot;parse like a statement&quot;.</p>
</blockquote>
<p>What if you have <em>one</em> expression? That should be a literal <code>1</code>.</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! count_exprs {
    () =&gt; (0);
    ($e:expr) =&gt; (1);
//  ^~~~~~~~~~~~~~~~~ added
}
<span class="boring">fn main() {
</span><span class="boring">    const _0: usize = count_exprs!();
</span><span class="boring">    const _1: usize = count_exprs!(x);
</span><span class="boring">    assert_eq!(_0, 0);
</span><span class="boring">    assert_eq!(_1, 1);
</span><span class="boring">}
</span></code></pre></pre>
<p>Two?</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! count_exprs {
    () =&gt; (0);
    ($e:expr) =&gt; (1);
    ($e0:expr, $e1:expr) =&gt; (2);
//  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~ added
}
<span class="boring">fn main() {
</span><span class="boring">    const _0: usize = count_exprs!();
</span><span class="boring">    const _1: usize = count_exprs!(x);
</span><span class="boring">    const _2: usize = count_exprs!(x, y);
</span><span class="boring">    assert_eq!(_0, 0);
</span><span class="boring">    assert_eq!(_1, 1);
</span><span class="boring">    assert_eq!(_2, 2);
</span><span class="boring">}
</span></code></pre></pre>
<p>We can &quot;simplify&quot; this a little by re-expressing the case of two expressions recursively.</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! count_exprs {
    () =&gt; (0);
    ($e:expr) =&gt; (1);
    ($e0:expr, $e1:expr) =&gt; (1 + count_exprs!($e1));
//                           ^~~~~~~~~~~~~~~~~~~~~ changed
}
<span class="boring">fn main() {
</span><span class="boring">    const _0: usize = count_exprs!();
</span><span class="boring">    const _1: usize = count_exprs!(x);
</span><span class="boring">    const _2: usize = count_exprs!(x, y);
</span><span class="boring">    assert_eq!(_0, 0);
</span><span class="boring">    assert_eq!(_1, 1);
</span><span class="boring">    assert_eq!(_2, 2);
</span><span class="boring">}
</span></code></pre></pre>
<p>This is fine since Rust can fold <code>1 + 1</code> into a constant value. What if we have three expressions?</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! count_exprs {
    () =&gt; (0);
    ($e:expr) =&gt; (1);
    ($e0:expr, $e1:expr) =&gt; (1 + count_exprs!($e1));
    ($e0:expr, $e1:expr, $e2:expr) =&gt; (1 + count_exprs!($e1, $e2));
//  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ added
}
<span class="boring">fn main() {
</span><span class="boring">    const _0: usize = count_exprs!();
</span><span class="boring">    const _1: usize = count_exprs!(x);
</span><span class="boring">    const _2: usize = count_exprs!(x, y);
</span><span class="boring">    const _3: usize = count_exprs!(x, y, z);
</span><span class="boring">    assert_eq!(_0, 0);
</span><span class="boring">    assert_eq!(_1, 1);
</span><span class="boring">    assert_eq!(_2, 2);
</span><span class="boring">    assert_eq!(_3, 3);
</span><span class="boring">}
</span></code></pre></pre>
<blockquote>
<p><strong>Aside</strong>: You might be wondering if we could reverse the order of these rules. In this particular
case, <em>yes</em>, but the macro system can sometimes be picky about what it is and is not willing to
recover from. If you ever find yourself with a multi-rule macro that you <em>swear</em> should work,
but gives you errors about unexpected tokens, try changing the order of the rules.</p>
</blockquote>
<p>Hopefully, you can see the pattern here. We can always reduce the list of expressions by matching
one expression, followed by zero or more expressions, expanding that into 1 + a count.</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! count_exprs {
    () =&gt; (0);
    ($head:expr) =&gt; (1);
    ($head:expr, $($tail:expr),*) =&gt; (1 + count_exprs!($($tail),*));
//  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ changed
}
<span class="boring">fn main() {
</span><span class="boring">    const _0: usize = count_exprs!();
</span><span class="boring">    const _1: usize = count_exprs!(x);
</span><span class="boring">    const _2: usize = count_exprs!(x, y);
</span><span class="boring">    const _3: usize = count_exprs!(x, y, z);
</span><span class="boring">    assert_eq!(_0, 0);
</span><span class="boring">    assert_eq!(_1, 1);
</span><span class="boring">    assert_eq!(_2, 2);
</span><span class="boring">    assert_eq!(_3, 3);
</span><span class="boring">}
</span></code></pre></pre>
<blockquote>
<p><strong><abbr title="Just for this example">JFTE</abbr></strong>: this is not the <em>only</em>, or even the <em>best</em>
way of counting things. You may wish to peruse the <a href="/blocks/counting.html">Counting</a> section later.</p>
</blockquote>
<p>With this, we can now modify <code>recurrence</code> to determine the necessary size of <code>mem</code>.</p>
<pre><pre class="playground"><code class="language-rust">// added:
macro_rules! count_exprs {
    () =&gt; (0);
    ($head:expr) =&gt; (1);
    ($head:expr, $($tail:expr),*) =&gt; (1 + count_exprs!($($tail),*));
}

macro_rules! recurrence {
    ( a[n]: $sty:ty = $($inits:expr),+ ; ... ; $recur:expr ) =&gt; {
        {
            use std::ops::Index;

            const MEM_SIZE: usize = count_exprs!($($inits),+);
//          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ added

            struct Recurrence {
                mem: [$sty; MEM_SIZE],
//                          ^~~~~~~~ changed
                pos: usize,
            }

            struct IndexOffset&lt;'a&gt; {
                slice: &amp;'a [$sty; MEM_SIZE],
//                                ^~~~~~~~ changed
                offset: usize,
            }

            impl&lt;'a&gt; Index&lt;usize&gt; for IndexOffset&lt;'a&gt; {
                type Output = $sty;

                #[inline(always)]
                fn index&lt;'b&gt;(&amp;'b self, index: usize) -&gt; &amp;'b $sty {
                    use std::num::Wrapping;

                    let index = Wrapping(index);
                    let offset = Wrapping(self.offset);
                    let window = Wrapping(MEM_SIZE);
//                                        ^~~~~~~~ changed

                    let real_index = index - offset + window;
                    &amp;self.slice[real_index.0]
                }
            }

            impl Iterator for Recurrence {
                type Item = $sty;

                #[inline]
                fn next(&amp;mut self) -&gt; Option&lt;$sty&gt; {
                    if self.pos &lt; MEM_SIZE {
//                                ^~~~~~~~ changed
                        let next_val = self.mem[self.pos];
                        self.pos += 1;
                        Some(next_val)
                    } else {
                        let next_val = {
                            let n = self.pos;
                            let a = IndexOffset { slice: &amp;self.mem, offset: n };
                            (a[n-1] + a[n-2])
                        };

                        {
                            use std::mem::swap;

                            let mut swap_tmp = next_val;
                            for i in (0..MEM_SIZE).rev() {
//                                       ^~~~~~~~ changed
                                swap(&amp;mut swap_tmp, &amp;mut self.mem[i]);
                            }
                        }

                        self.pos += 1;
                        Some(next_val)
                    }
                }
            }

            Recurrence { mem: [$($inits),+], pos: 0 }
        }
    };
}
/* ... */
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let fib = recurrence![a[n]: u64 = 0, 1; ...; a[n-1] + a[n-2]];
</span><span class="boring">
</span><span class="boring">    for e in fib.take(10) { println!(&quot;{}&quot;, e) }
</span><span class="boring">}
</span></code></pre></pre>
<p>With that done, we can now substitute the last thing: the <code>recur</code> expression.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">macro_rules! count_exprs {
</span><span class="boring">    () =&gt; (0);
</span><span class="boring">    ($head:expr $(, $tail:expr)*) =&gt; (1 + count_exprs!($($tail),*));
</span><span class="boring">}
</span><span class="boring">macro_rules! recurrence {
</span><span class="boring">    ( a[n]: $sty:ty = $($inits:expr),+ ; ... ; $recur:expr ) =&gt; {
</span><span class="boring">        {
</span><span class="boring">            use std::ops::Index;
</span><span class="boring">
</span><span class="boring">            const MEM_SIZE: usize = count_exprs!($($inits),+);
</span><span class="boring">            struct Recurrence {
</span><span class="boring">                mem: [$sty; MEM_SIZE],
</span><span class="boring">                pos: usize,
</span><span class="boring">            }
</span><span class="boring">            struct IndexOffset&lt;'a&gt; {
</span><span class="boring">                slice: &amp;'a [$sty; MEM_SIZE],
</span><span class="boring">                offset: usize,
</span><span class="boring">            }
</span><span class="boring">            impl&lt;'a&gt; Index&lt;usize&gt; for IndexOffset&lt;'a&gt; {
</span><span class="boring">                type Output = $sty;
</span><span class="boring">
</span><span class="boring">                #[inline(always)]
</span><span class="boring">                fn index&lt;'b&gt;(&amp;'b self, index: usize) -&gt; &amp;'b $sty {
</span><span class="boring">                    use std::num::Wrapping;
</span><span class="boring">
</span><span class="boring">                    let index = Wrapping(index);
</span><span class="boring">                    let offset = Wrapping(self.offset);
</span><span class="boring">                    let window = Wrapping(MEM_SIZE);
</span><span class="boring">
</span><span class="boring">                    let real_index = index - offset + window;
</span><span class="boring">                    &amp;self.slice[real_index.0]
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">            impl Iterator for Recurrence {
</span><span class="boring">              type Item = $sty;
</span>/* ... */
                #[inline]
                fn next(&amp;mut self) -&gt; Option&lt;u64&gt; {
                    if self.pos &lt; MEM_SIZE {
                        let next_val = self.mem[self.pos];
                        self.pos += 1;
                        Some(next_val)
                    } else {
                        let next_val = {
                            let n = self.pos;
                            let a = IndexOffset { slice: &amp;self.mem, offset: n };
                            $recur
//                          ^~~~~~ changed
                        };
                        {
                            use std::mem::swap;
                            let mut swap_tmp = next_val;
                            for i in (0..MEM_SIZE).rev() {
                                swap(&amp;mut swap_tmp, &amp;mut self.mem[i]);
                            }
                        }
                        self.pos += 1;
                        Some(next_val)
                    }
                }
/* ... */
<span class="boring">            }
</span><span class="boring">            Recurrence { mem: [$($inits),+], pos: 0 }
</span><span class="boring">        }
</span><span class="boring">    };
</span><span class="boring">}
</span><span class="boring">fn main() {
</span><span class="boring">    let fib = recurrence![a[n]: u64 = 1, 1; ...; a[n-1] + a[n-2]];
</span><span class="boring">    for e in fib.take(10) { println!(&quot;{}&quot;, e) }
</span><span class="boring">}
</span></code></pre></pre>
<p>And, when we compile our finished macro...</p>
<pre><code class="language-text">error[E0425]: cannot find value `a` in this scope
  --&gt; src/main.rs:68:50
   |
68 |     let fib = recurrence![a[n]: u64 = 1, 1; ...; a[n-1] + a[n-2]];
   |                                                  ^ not found in this scope

error[E0425]: cannot find value `n` in this scope
  --&gt; src/main.rs:68:52
   |
68 |     let fib = recurrence![a[n]: u64 = 1, 1; ...; a[n-1] + a[n-2]];
   |                                                    ^ not found in this scope

error[E0425]: cannot find value `a` in this scope
  --&gt; src/main.rs:68:59
   |
68 |     let fib = recurrence![a[n]: u64 = 1, 1; ...; a[n-1] + a[n-2]];
   |                                                           ^ not found in this scope

error[E0425]: cannot find value `n` in this scope
  --&gt; src/main.rs:68:61
   |
68 |     let fib = recurrence![a[n]: u64 = 1, 1; ...; a[n-1] + a[n-2]];
   |                                                             ^ not found in this scope
</code></pre>
<p>... wait, what? That can't be right... let's check what the macro is expanding to.</p>
<pre><code class="language-shell">$ rustc -Z unstable-options --pretty expanded recurrence.rs
</code></pre>
<p>The <code>--pretty expanded</code> argument tells <code>rustc</code> to perform macro expansion, then turn the resulting
AST back into source code. Because this option isn't considered stable yet, we also need
<code>-Z unstable-options</code>. The output (after cleaning up some formatting) is shown below; in particular,
note the place in the code where <code>$recur</code> was substituted:</p>
<pre><code class="language-rust ignore">#![feature(no_std)]
#![no_std]
#[prelude_import]
use std::prelude::v1::*;
#[macro_use]
extern crate std as std;
fn main() {
    let fib = {
        use std::ops::Index;
        const MEM_SIZE: usize = 1 + 1;
        struct Recurrence {
            mem: [u64; MEM_SIZE],
            pos: usize,
        }
        struct IndexOffset&lt;'a&gt; {
            slice: &amp;'a [u64; MEM_SIZE],
            offset: usize,
        }
        impl &lt;'a&gt; Index&lt;usize&gt; for IndexOffset&lt;'a&gt; {
            type Output = u64;
            #[inline(always)]
            fn index&lt;'b&gt;(&amp;'b self, index: usize) -&gt; &amp;'b u64 {
                use std::num::Wrapping;
                let index = Wrapping(index);
                let offset = Wrapping(self.offset);
                let window = Wrapping(MEM_SIZE);
                let real_index = index - offset + window;
                &amp;self.slice[real_index.0]
            }
        }
        impl Iterator for Recurrence {
            type Item = u64;
            #[inline]
            fn next(&amp;mut self) -&gt; Option&lt;u64&gt; {
                if self.pos &lt; MEM_SIZE {
                    let next_val = self.mem[self.pos];
                    self.pos += 1;
                    Some(next_val)
                } else {
                    let next_val = {
                        let n = self.pos;
                        let a = IndexOffset{slice: &amp;self.mem, offset: n,};
                        a[n - 1] + a[n - 2]
                    };
                    {
                        use std::mem::swap;
                        let mut swap_tmp = next_val;
                        {
                            let result =
                                match ::std::iter::IntoIterator::into_iter((0..MEM_SIZE).rev()) {
                                    mut iter =&gt; loop {
                                        match ::std::iter::Iterator::next(&amp;mut iter) {
                                            ::std::option::Option::Some(i) =&gt; {
                                                swap(&amp;mut swap_tmp, &amp;mut self.mem[i]);
                                            }
                                            ::std::option::Option::None =&gt; break,
                                        }
                                    },
                                };
                            result
                        }
                    }
                    self.pos += 1;
                    Some(next_val)
                }
            }
        }
        Recurrence{mem: [0, 1], pos: 0,}
    };
    {
        let result =
            match ::std::iter::IntoIterator::into_iter(fib.take(10)) {
                mut iter =&gt; loop {
                    match ::std::iter::Iterator::next(&amp;mut iter) {
                        ::std::option::Option::Some(e) =&gt; {
                            ::std::io::_print(::std::fmt::Arguments::new_v1(
                                {
                                    static __STATIC_FMTSTR: &amp;'static [&amp;'static str] = &amp;[&quot;&quot;, &quot;\n&quot;];
                                    __STATIC_FMTSTR
                                },
                                &amp;match (&amp;e,) {
                                    (__arg0,) =&gt; [::std::fmt::ArgumentV1::new(__arg0, ::std::fmt::Display::fmt)],
                                }
                            ))
                        }
                        ::std::option::Option::None =&gt; break,
                    }
                },
            };
        result
    }
}
</code></pre>
<p>But that looks fine! If we add a few missing <code>#![feature(...)]</code> attributes and feed it to a nightly
build of <code>rustc</code>, it even compiles!  ... <em>what?!</em></p>
<blockquote>
<p><strong>Aside</strong>: You can't compile the above with a non-nightly build of <code>rustc</code>. This is because the
expansion of the <code>println!</code> macro depends on internal compiler details which are <em>not</em> publicly
stabilised.</p>
</blockquote>
<h3 id="being-hygienic"><a class="header" href="#being-hygienic">Being Hygienic</a></h3>
<p>The issue here is that identifiers in Rust macros are <em>hygienic</em>. That is, identifiers from two
different contexts <em>cannot</em> collide. To show the difference, let's take a simpler example.</p>
<pre><code class="language-rust ignore">macro_rules! using_a {
    ($e:expr) =&gt; {
        {
            let a = 42i;
            $e
        }
    }
}

let four = using_a!(a / 10);
<span class="boring">fn main() {}
</span></code></pre>
<p>This macro simply takes an expression, then wraps it in a block with a variable <code>a</code> defined. We then
use this as a round-about way of computing <code>4</code>. There are actually <em>two</em> syntax contexts involved in
this example, but they're invisible. So, to help with this, let's give each context a different
colour. Let's start with the unexpanded code, where there is only a single context:</p>
<pre class="rust rust-example-rendered"><span class="synctx-0"><span class="macro">macro_rules</span><span class="macro">!</span> <span class="ident">using_a</span> {&#xa;    (<span class="macro-nonterminal">$</span><span class="macro-nonterminal">e</span>:<span class="ident">expr</span>) <span class="op">=&gt;</span> {&#xa;        {&#xa;            <span class="kw">let</span> <span class="ident">a</span> <span class="op">=</span> <span class="number">42</span>;&#xa;            <span class="macro-nonterminal">$</span><span class="macro-nonterminal">e</span>&#xa;        }&#xa;    }&#xa;}&#xa;&#xa;<span class="kw">let</span> <span class="ident">four</span> <span class="op">=</span> <span class="macro">using_a</span><span class="macro">!</span>(<span class="ident">a</span> <span class="op">/</span> <span class="number">10</span>);</span></pre>
<p>Now, let's expand the invocation.</p>
<pre class="rust rust-example-rendered"><span class="synctx-0"><span class="kw">let</span> <span class="ident">four</span> <span class="op">=</span> </span><span class="synctx-1">{&#xa;    <span class="kw">let</span> <span class="ident">a</span> <span class="op">=</span> <span class="number">42</span>;&#xa;    </span><span class="synctx-0"><span class="ident">a</span> <span class="op">/</span> <span class="number">10</span></span><span class="synctx-1">&#xa;}</span><span class="synctx-0">;</span></pre>
<p>As you can see, the <code><span class="synctx-1">a</span></code> that's defined by the macro is in a
different context to the <code><span class="synctx-0">a</span></code> we provided in our invocation.
As such, the compiler treats them as completely different identifiers,
<em>even though they have the same lexical appearance</em>.</p>
<p>This is something to be <em>really</em> careful of when working on macros: macros can produce ASTs which
will not compile, but which <em>will</em> compile if written out by hand, or dumped using
<code>--pretty expanded</code>.</p>
<p>The solution to this is to capture the identifier <em>with the appropriate syntax context</em>. To do that,
we need to again adjust our macro syntax. To continue with our simpler example:</p>
<pre class="rust rust-example-rendered"><span class="synctx-0"><span class="macro">macro_rules</span><span class="macro">!</span> <span class="ident">using_a</span> {&#xa;    (<span class="macro-nonterminal">$</span><span class="macro-nonterminal">a</span>:<span class="ident">ident</span>, <span class="macro-nonterminal">$</span><span class="macro-nonterminal">e</span>:<span class="ident">expr</span>) <span class="op">=&gt;</span> {&#xa;        {&#xa;            <span class="kw">let</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">a</span> <span class="op">=</span> <span class="number">42</span>;&#xa;            <span class="macro-nonterminal">$</span><span class="macro-nonterminal">e</span>&#xa;        }&#xa;    }&#xa;}&#xa;&#xa;<span class="kw">let</span> <span class="ident">four</span> <span class="op">=</span> <span class="macro">using_a</span><span class="macro">!</span>(<span class="ident">a</span>, <span class="ident">a</span> <span class="op">/</span> <span class="number">10</span>);</span></pre>
<p>This now expands to:</p>
<pre class="rust rust-example-rendered"><span class="synctx-0"><span class="kw">let</span> <span class="ident">four</span> <span class="op">=</span> </span><span class="synctx-1">{&#xa;    <span class="kw">let</span> </span><span class="synctx-0"><span class="ident">a</span></span><span class="synctx-1"> <span class="op">=</span> <span class="number">42</span>;&#xa;    </span><span class="synctx-0"><span class="ident">a</span> <span class="op">/</span> <span class="number">10</span></span><span class="synctx-1">&#xa;}</span><span class="synctx-0">;</span></pre>
<p>Now, the contexts match, and the code will compile.  We can make this adjustment to our
<code>recurrence!</code> macro by explicitly capturing <code>a</code> and <code>n</code>.  After making the necessary changes, we
have:</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! count_exprs {
    () =&gt; (0);
    ($head:expr) =&gt; (1);
    ($head:expr, $($tail:expr),*) =&gt; (1 + count_exprs!($($tail),*));
}

macro_rules! recurrence {
    ( $seq:ident [ $ind:ident ]: $sty:ty = $($inits:expr),+ ; ... ; $recur:expr ) =&gt; {
//    ^~~~~~~~~~   ^~~~~~~~~~ changed
        {
            use std::ops::Index;

            const MEM_SIZE: usize = count_exprs!($($inits),+);

            struct Recurrence {
                mem: [$sty; MEM_SIZE],
                pos: usize,
            }

            struct IndexOffset&lt;'a&gt; {
                slice: &amp;'a [$sty; MEM_SIZE],
                offset: usize,
            }

            impl&lt;'a&gt; Index&lt;usize&gt; for IndexOffset&lt;'a&gt; {
                type Output = $sty;

                #[inline(always)]
                fn index&lt;'b&gt;(&amp;'b self, index: usize) -&gt; &amp;'b $sty {
                    use std::num::Wrapping;

                    let index = Wrapping(index);
                    let offset = Wrapping(self.offset);
                    let window = Wrapping(MEM_SIZE);

                    let real_index = index - offset + window;
                    &amp;self.slice[real_index.0]
                }
            }

            impl Iterator for Recurrence {
                type Item = $sty;

                #[inline]
                fn next(&amp;mut self) -&gt; Option&lt;$sty&gt; {
                    if self.pos &lt; MEM_SIZE {
                        let next_val = self.mem[self.pos];
                        self.pos += 1;
                        Some(next_val)
                    } else {
                        let next_val = {
                            let $ind = self.pos;
//                              ^~~~ changed
                            let $seq = IndexOffset { slice: &amp;self.mem, offset: $ind };
//                              ^~~~ changed
                            $recur
                        };

                        {
                            use std::mem::swap;

                            let mut swap_tmp = next_val;
                            for i in (0..MEM_SIZE).rev() {
                                swap(&amp;mut swap_tmp, &amp;mut self.mem[i]);
                            }
                        }

                        self.pos += 1;
                        Some(next_val)
                    }
                }
            }

            Recurrence { mem: [$($inits),+], pos: 0 }
        }
    };
}

fn main() {
    let fib = recurrence![a[n]: u64 = 0, 1; ...; a[n-1] + a[n-2]];

    for e in fib.take(10) { println!(&quot;{}&quot;, e) }
}
</code></pre></pre>
<p>And it compiles!  Now, let's try with a different sequence.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">macro_rules! count_exprs {
</span><span class="boring">    () =&gt; (0);
</span><span class="boring">    ($head:expr) =&gt; (1);
</span><span class="boring">    ($head:expr, $($tail:expr),*) =&gt; (1 + count_exprs!($($tail),*));
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">macro_rules! recurrence {
</span><span class="boring">    ( $seq:ident [ $ind:ident ]: $sty:ty = $($inits:expr),+ ; ... ; $recur:expr ) =&gt; {
</span><span class="boring">        {
</span><span class="boring">            use std::ops::Index;
</span><span class="boring">            
</span><span class="boring">            const MEM_SIZE: usize = count_exprs!($($inits),+);
</span><span class="boring">    
</span><span class="boring">            struct Recurrence {
</span><span class="boring">                mem: [$sty; MEM_SIZE],
</span><span class="boring">                pos: usize,
</span><span class="boring">            }
</span><span class="boring">    
</span><span class="boring">            struct IndexOffset&lt;'a&gt; {
</span><span class="boring">                slice: &amp;'a [$sty; MEM_SIZE],
</span><span class="boring">                offset: usize,
</span><span class="boring">            }
</span><span class="boring">    
</span><span class="boring">            impl&lt;'a&gt; Index&lt;usize&gt; for IndexOffset&lt;'a&gt; {
</span><span class="boring">                type Output = $sty;
</span><span class="boring">    
</span><span class="boring">                #[inline(always)]
</span><span class="boring">                fn index&lt;'b&gt;(&amp;'b self, index: usize) -&gt; &amp;'b $sty {
</span><span class="boring">                    use std::num::Wrapping;
</span><span class="boring">                    
</span><span class="boring">                    let index = Wrapping(index);
</span><span class="boring">                    let offset = Wrapping(self.offset);
</span><span class="boring">                    let window = Wrapping(MEM_SIZE);
</span><span class="boring">                    
</span><span class="boring">                    let real_index = index - offset + window;
</span><span class="boring">                    &amp;self.slice[real_index.0]
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">    
</span><span class="boring">            impl Iterator for Recurrence {
</span><span class="boring">                type Item = $sty;
</span><span class="boring">    
</span><span class="boring">                #[inline]
</span><span class="boring">                fn next(&amp;mut self) -&gt; Option&lt;$sty&gt; {
</span><span class="boring">                    if self.pos &lt; MEM_SIZE {
</span><span class="boring">                        let next_val = self.mem[self.pos];
</span><span class="boring">                        self.pos += 1;
</span><span class="boring">                        Some(next_val)
</span><span class="boring">                    } else {
</span><span class="boring">                        let next_val = {
</span><span class="boring">                            let $ind = self.pos;
</span><span class="boring">                            let $seq = IndexOffset { slice: &amp;self.mem, offset: $ind };
</span><span class="boring">                            $recur
</span><span class="boring">                        };
</span><span class="boring">    
</span><span class="boring">                        {
</span><span class="boring">                            use std::mem::swap;
</span><span class="boring">    
</span><span class="boring">                            let mut swap_tmp = next_val;
</span><span class="boring">                            for i in (0..MEM_SIZE).rev() {
</span><span class="boring">                                swap(&amp;mut swap_tmp, &amp;mut self.mem[i]);
</span><span class="boring">                            }
</span><span class="boring">                        }
</span><span class="boring">    
</span><span class="boring">                        self.pos += 1;
</span><span class="boring">                        Some(next_val)
</span><span class="boring">                    }
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">    
</span><span class="boring">            Recurrence { mem: [$($inits),+], pos: 0 }
</span><span class="boring">        }
</span><span class="boring">    };
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span>for e in recurrence!(f[i]: f64 = 1.0; ...; f[i-1] * i as f64).take(10) {
    println!(&quot;{}&quot;, e)
}
<span class="boring">}
</span></code></pre></pre>
<p>Which gives us:</p>
<pre><code class="language-text">1
1
2
6
24
120
720
5040
40320
362880
</code></pre>
<p>Success!</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="patterns"><a class="header" href="#patterns">Patterns</a></h1>
<p>Parsing and expansion patterns.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="callbacks"><a class="header" href="#callbacks">Callbacks</a></h1>
<pre><pre class="playground"><code class="language-rust">macro_rules! call_with_larch {
    ($callback:ident) =&gt; { $callback!(larch) };
}

macro_rules! expand_to_larch {
    () =&gt; { larch };
}

macro_rules! recognize_tree {
    (larch) =&gt; { println!(&quot;#1, the Larch.&quot;) };
    (redwood) =&gt; { println!(&quot;#2, the Mighty Redwood.&quot;) };
    (fir) =&gt; { println!(&quot;#3, the Fir.&quot;) };
    (chestnut) =&gt; { println!(&quot;#4, the Horse Chestnut.&quot;) };
    (pine) =&gt; { println!(&quot;#5, the Scots Pine.&quot;) };
    ($($other:tt)*) =&gt; { println!(&quot;I don't know; some kind of birch maybe?&quot;) };
}

fn main() {
    recognize_tree!(expand_to_larch!());
    call_with_larch!(recognize_tree);
}
</code></pre></pre>
<p>Due to the order that macros are expanded in, it is (as of Rust 1.2) impossible to pass information
to a macro from the expansion of <em>another</em> macro. This can make modularizing macros very difficult.</p>
<p>An alternative is to use recursion and pass a callback. Here is a trace of the above example to
demonstrate how this takes place:</p>
<pre><code class="language-rust ignore">recognize_tree! { expand_to_larch ! (  ) }
println! { &quot;I don't know; some kind of birch maybe?&quot; }
// ...

call_with_larch! { recognize_tree }
recognize_tree! { larch }
println! { &quot;#1, the Larch.&quot; }
// ...
</code></pre>
<p>Using a <code>tt</code> repetition, one can also forward arbitrary arguments to a callback.</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! callback {
    ($callback:ident( $($args:tt)* )) =&gt; {
        $callback!( $($args)* )
    };
}

fn main() {
    callback!(callback(println(&quot;Yes, this *was* unnecessary.&quot;)));
}
</code></pre></pre>
<p>You can, of course, insert additional tokens in the arguments as needed.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="incremental-tt-munchers"><a class="header" href="#incremental-tt-munchers">Incremental TT Munchers</a></h1>
<pre><pre class="playground"><code class="language-rust">macro_rules! mixed_rules {
    () =&gt; {};
    (trace $name:ident; $($tail:tt)*) =&gt; {
        {
            println!(concat!(stringify!($name), &quot; = {:?}&quot;), $name);
            mixed_rules!($($tail)*);
        }
    };
    (trace $name:ident = $init:expr; $($tail:tt)*) =&gt; {
        {
            let $name = $init;
            println!(concat!(stringify!($name), &quot; = {:?}&quot;), $name);
            mixed_rules!($($tail)*);
        }
    };
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let a = 42;
</span><span class="boring">    let b = &quot;Ho-dee-oh-di-oh-di-oh!&quot;;
</span><span class="boring">    let c = (false, 2, 'c');
</span><span class="boring">    mixed_rules!(
</span><span class="boring">        trace a;
</span><span class="boring">        trace b;
</span><span class="boring">        trace c;
</span><span class="boring">        trace b = &quot;They took her where they put the crazies.&quot;;
</span><span class="boring">        trace b;
</span><span class="boring">    );
</span><span class="boring">}
</span></code></pre></pre>
<p>This pattern is perhaps the <em>most powerful</em> macro parsing technique available, allowing one to parse
grammars of significant complexity.</p>
<p>A <code>TT muncher</code> is a recursive macro that works by incrementally processing its input one step at a
time. At each step, it matches and removes (munches) some sequence of tokens from the start of its
input, generates some intermediate output, then recurses on the input tail.</p>
<p>The reason for &quot;TT&quot; in the name specifically is that the unprocessed part of the input is <em>always</em>
captured as <code>$($tail:tt)*</code>. This is done as a <a href="patterns/./fragment-specifiers.html#tt"><code>tt</code></a> repetition is the only way to <em>losslessly</em>
capture part of a macro's input.</p>
<p>The only hard restrictions on TT munchers are those imposed on the macro system as a whole:</p>
<ul>
<li>You can only match against literals and grammar constructs which can be captured by <code>macro_rules!</code>.</li>
<li>You cannot match unbalanced groups.</li>
</ul>
<p>It is important, however, to keep the macro recursion limit in mind. <code>macro_rules!</code> does not have
<em>any</em> form of tail recursion elimination or optimization. It is recommended that, when writing a TT
muncher, you make reasonable efforts to keep recursion as limited as possible. This can be done by
adding additional rules to account for variation in the input (as opposed to recursion into an
intermediate layer), or by making compromises on the input syntax to make using standard repetitions
more tractable.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="internal-rules"><a class="header" href="#internal-rules">Internal Rules</a></h1>
<pre><pre class="playground"><code class="language-rust">#[macro_export]
macro_rules! foo {
    (@as_expr $e:expr) =&gt; {$e};

    ($($tts:tt)*) =&gt; {
        foo!(@as_expr $($tts)*)
    };
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    assert_eq!(foo!(42), 42);
</span><span class="boring">}
</span></code></pre></pre>
<p>Internal rules can be used to unify multiple macros into one, or to make it easier to read and write
<a href="patterns/./tt-muncher.html">TT Munchers</a> by explicitly naming what rule you wish to call in a macro.</p>
<p>So why is it useful to unify multiple macros into one? The main reasoning for this is how macros are
handled in the 2015 Edition of Rust due to macros not being namespaced in said edition. This gives
one the troubles of having to re-export all the internal macros as well polluting the global macro
namespace or even worse, macro name collisions with other crates. In short, it's quite a hassle.
This fortunately isn't really a problem anymore nowadays with a rustc version &gt;= 1.30, for more
information consult the <a href="patterns//macros/minutiae/import-export.html">Import and Export chapter</a>. </p>
<p>Nevertheless, let's talk about how we can unify multiple macros into one with this technique and
what exactly this technique even is.</p>
<p>We have two macros, the common <a href="patterns//building-blocks/ast-coercion.html"><code>as_expr!</code> macro</a> and a <code>foo</code>
macro that makes use of the first macro:</p>
<pre><pre class="playground"><code class="language-rust">#[macro_export]
macro_rules! as_expr { ($e:expr) =&gt; {$e} }

#[macro_export]
macro_rules! foo {
    ($($tts:tt)*) =&gt; {
        as_expr!($($tts)*)
    };
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    assert_eq!(foo!(42), 42);
</span><span class="boring">}
</span></code></pre></pre>
<p>This is definitely not the nicest solution we could have for this macro, as it pollutes the global
macro namespace as mentioned earlier. In this specific case <code>as_expr</code> is also a very simple macro
that we only used once, so let's &quot;embed&quot; this macro in our <code>foo</code> macro with internal rules! To do so
we simply prepend a new matcher for our macro consists of the matcher used in the <code>as_expr</code> macro,
but with a small addition. We prepend a tokentree that makes it match only when specifically asked
to. In this case we can for example use <code>@as_expr</code>, so our matcher becomes
<code>(@as_expr $e:expr) =&gt; {$e};</code>. With this we get the macro that was defined at the very top of this
page:</p>
<pre><pre class="playground"><code class="language-rust">#[macro_export]
macro_rules! foo {
    (@as_expr $e:expr) =&gt; {$e};

    ($($tts:tt)*) =&gt; {
        foo!(@as_expr $($tts)*)
    };
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    assert_eq!(foo!(42), 42);
</span><span class="boring">}
</span></code></pre></pre>
<p>You see how we embedded the <code>as_expr</code> macro in the <code>foo</code> one? All that changed is that instead of
invoking the <code>as_expr</code> macro, we now invoke <code>foo</code> recursively but with a special token tree
prepended to the arguments, <code>foo!(@as_expr $($tts)*)</code>. If you look closely you might even see that
this pattern can be combined quite nicely with <a href="patterns/./tt-muncher.html">TT Munchers</a>!</p>
<p>The reason for using <code>@</code> was that, as of Rust 1.2, the <code>@</code> token is <em>not</em> used in prefix position; as
such, it cannot conflict with anything. This reasoning became obsolete later on when in Rust 1.7
macro matchers got future proofed by emitting a warning to prevent certain tokens from being allowed
to follow certain fragments<sup class="footnote-reference"><a href="#ambiguity-restrictions">1</a></sup>, which in Rust 1.12 became a hard-error. There
other symbols or unique prefixes may be used as desired, but use of <code>@</code> has started to become
widespread, so using it may aid readers in understanding your macro.</p>
<div class="footnote-definition" id="ambiguity-restrictions"><sup class="footnote-definition-label">1</sup>
<p><a href="patterns//macros/minutiae/metavar-and-expansion.html">ambiguity-restrictions</a></p>
</div>
<blockquote>
<p><strong>Note</strong>: in the early days of Rust the <code>@</code> token was previously used in prefix position to denote
a garbage-collected pointer, back when the language used sigils to denote pointer types. Its
only <em>current</em> purpose is for binding names to patterns. For this, however, it is used as an
<em>infix</em> operator, and thus does not conflict with its use here.</p>
</blockquote>
<p>Additionally, internal rules will often come <em>before</em> any &quot;bare&quot; rules, to avoid issues with
<code>macro_rules!</code> incorrectly attempting to parse an internal invocation as something it cannot
possibly be, such as an expression.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="push-down-accumulation"><a class="header" href="#push-down-accumulation">Push-down Accumulation</a></h1>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! init_array {
    (@accum (0, $_e:expr) -&gt; ($($body:tt)*))
        =&gt; {init_array!(@as_expr [$($body)*])};
    (@accum (1, $e:expr) -&gt; ($($body:tt)*))
        =&gt; {init_array!(@accum (0, $e) -&gt; ($($body)* $e,))};
    (@accum (2, $e:expr) -&gt; ($($body:tt)*))
        =&gt; {init_array!(@accum (1, $e) -&gt; ($($body)* $e,))};
    (@accum (3, $e:expr) -&gt; ($($body:tt)*))
        =&gt; {init_array!(@accum (2, $e) -&gt; ($($body)* $e,))};
    (@as_expr $e:expr) =&gt; {$e};
    [$e:expr; $n:tt] =&gt; {
        {
            let e = $e;
            init_array!(@accum ($n, e.clone()) -&gt; ())
        }
    };
}

let strings: [String; 3] = init_array![String::from(&quot;hi!&quot;); 3];
<span class="boring">assert_eq!(format!(&quot;{:?}&quot;, strings), &quot;[\&quot;hi!\&quot;, \&quot;hi!\&quot;, \&quot;hi!\&quot;]&quot;);
</span><span class="boring">}
</span></code></pre></pre>
<p>All macros in Rust <strong>must</strong> result in a complete, supported syntax element (such as an expression,
item, <em>etc.</em>). This means that it is impossible to have a macro expand to a partial construct.</p>
<p>One might hope that the above example could be more directly expressed like so:</p>
<pre><code class="language-ignore">macro_rules! init_array {
    (@accum 0, $_e:expr) =&gt; {/* empty */};
    (@accum 1, $e:expr) =&gt; {$e};
    (@accum 2, $e:expr) =&gt; {$e, init_array!(@accum 1, $e)};
    (@accum 3, $e:expr) =&gt; {$e, init_array!(@accum 2, $e)};
    [$e:expr; $n:tt] =&gt; {
        {
            let e = $e;
            [init_array!(@accum $n, e)]
        }
    };
}
</code></pre>
<p>The expectation is that the expansion of the array literal would proceed as follows:</p>
<pre><code class="language-rust ignore">            [init_array!(@accum 3, e)]
            [e, init_array!(@accum 2, e)]
            [e, e, init_array!(@accum 1, e)]
            [e, e, e]
</code></pre>
<p>However, this would require each intermediate step to expand to an incomplete expression. Even
though the intermediate results will never be used <em>outside</em> of a macro context, it is still
forbidden.</p>
<p>Push-down, however, allows us to incrementally build up a sequence of tokens without needing to
actually have a complete construct at any point prior to completion. In the example given at the
top, the sequence of macro invocations proceeds as follows:</p>
<pre><code class="language-rust ignore">init_array! { String:: from ( &quot;hi!&quot; ) ; 3 }
init_array! { @ accum ( 3 , e . clone (  ) ) -&gt; (  ) }
init_array! { @ accum ( 2 , e.clone() ) -&gt; ( e.clone() , ) }
init_array! { @ accum ( 1 , e.clone() ) -&gt; ( e.clone() , e.clone() , ) }
init_array! { @ accum ( 0 , e.clone() ) -&gt; ( e.clone() , e.clone() , e.clone() , ) }
init_array! { @ as_expr [ e.clone() , e.clone() , e.clone() , ] }
</code></pre>
<p>As you can see, each layer adds to the accumulated output until the terminating rule finally emits
it as a complete construct.</p>
<p>The only critical part of the above formulation is the use of <code>$($body:tt)*</code> to preserve the output
without triggering parsing. The use of <code>($input) -&gt; ($output)</code> is simply a convention adopted to
help clarify the behavior of such macros.</p>
<p>Push-down accumulation is frequently used as part of
<a href="patterns/./tt-muncher.html">incremental TT munchers</a>, as it allows arbitrarily complex intermediate
results to be constructed. <a href="patterns/./internal-rules.html">Internal Rules</a> were of use
here as well, as they simplify creating such macros.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="repetition-replacement"><a class="header" href="#repetition-replacement">Repetition Replacement</a></h1>
<pre><code class="language-rust ignore">macro_rules! replace_expr {
    ($_t:tt $sub:expr) =&gt; {$sub};
}
</code></pre>
<p>This pattern is where a matched repetition sequence is simply discarded, with the variable being
used to instead drive some repeated pattern that is related to the input only in terms of length.</p>
<p>For example, consider constructing a default instance of a tuple with more than 12 elements (the
limit as of Rust 1.2).</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! tuple_default {
    ($($tup_tys:ty),*) =&gt; {
        (
            $(
                replace_expr!(
                    ($tup_tys)
                    Default::default()
                ),
            )*
        )
    };
}
<span class="boring">
</span><span class="boring">macro_rules! replace_expr {
</span><span class="boring">    ($_t:tt $sub:expr) =&gt; {$sub};
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">assert_eq!(tuple_default!(i32, bool, String), (i32::default(), bool::default(), String::default()));
</span><span class="boring">}
</span></code></pre></pre>
<blockquote>
<p><strong><abbr title="Just for this example">JFTE</abbr></strong>: we <em>could</em> have simply used
<code>$tup_tys::default()</code>.</p>
</blockquote>
<p>Here, we are not actually <em>using</em> the matched types. Instead, we throw them away and replace them
with a single, repeated expression. To put it another way, we don't care <em>what</em> the types are, only
<em>how many</em> there are.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="tt-bundling"><a class="header" href="#tt-bundling">TT Bundling</a></h1>
<pre><pre class="playground"><code class="language-rust">macro_rules! call_a_or_b_on_tail {
    ((a: $a:ident, b: $b:ident), call a: $($tail:tt)*) =&gt; {
        $a(stringify!($($tail)*))
    };

    ((a: $a:ident, b: $b:ident), call b: $($tail:tt)*) =&gt; {
        $b(stringify!($($tail)*))
    };

    ($ab:tt, $_skip:tt $($tail:tt)*) =&gt; {
        call_a_or_b_on_tail!($ab, $($tail)*)
    };
}

fn compute_len(s: &amp;str) -&gt; Option&lt;usize&gt; {
    Some(s.len())
}

fn show_tail(s: &amp;str) -&gt; Option&lt;usize&gt; {
    println!(&quot;tail: {:?}&quot;, s);
    None
}

fn main() {
    assert_eq!(
        call_a_or_b_on_tail!(
            (a: compute_len, b: show_tail),
            the recursive part that skips over all these
            tokens doesn't much care whether we will call a
            or call b: only the terminal rules care.
        ),
        None
    );
    assert_eq!(
        call_a_or_b_on_tail!(
            (a: compute_len, b: show_tail),
            and now, to justify the existence of two paths
            we will also call a: its input should somehow
            be self-referential, so let's make it return
            some eighty-six!
        ),
        Some(92)
    );
}
</code></pre></pre>
<p>In particularly complex recursive macros, a large number of arguments may be needed in order to
carry identifiers and expressions to successive layers. However, depending on the implementation
there may be many intermediate layers which need to forward these arguments, but do not need to
<em>use</em> them.</p>
<p>As such, it can be very useful to bundle all such arguments together into a single TT by placing
them in a group. This allows layers which do not need to use the arguments to simply capture and
substitute a single <a href="patterns/./fragment-specifiers.html#tt"><code>tt</code></a>, rather than having to exactly capture and substitute the entire argument
group.</p>
<p>The example above bundles the <code>$a</code> and <code>$b</code> expressions into a group which can then be forwarded as
a single <a href="patterns/./fragment-specifiers.html#tt"><code>tt</code></a> by the recursive rule. This group is then destructured by the terminal rules to
access the expressions.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="building-blocks"><a class="header" href="#building-blocks">Building Blocks</a></h1>
<p>Reusable snippets of macro code.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="ast-coercion"><a class="header" href="#ast-coercion">AST Coercion</a></h1>
<p>The Rust parser is not very robust in the face of <code>tt</code> substitutions. Problems can arise when the
parser is expecting a particular grammar construct and <em>instead</em> finds a lump of substituted <code>tt</code>
tokens. Rather than attempt to parse them, it will often just <em>give up</em>. In these cases, it is
necessary to employ an AST coercion.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(dead_code)]
</span>macro_rules! as_expr { ($e:expr) =&gt; {$e} }
macro_rules! as_item { ($i:item) =&gt; {$i} }
macro_rules! as_pat  { ($p:pat)  =&gt; {$p} }
macro_rules! as_stmt { ($s:stmt) =&gt; {$s} }
macro_rules! as_ty   { ($t:ty)   =&gt; {$t} }

as_item!{struct Dummy;}

fn main() {
    as_stmt!(let as_pat!(_): as_ty!(_) = as_expr!(42));
}
</code></pre></pre>
<p>These coercions are often used with <a href="building-blocks/../patterns/push-down-acc.html">push-down accumulation</a> macros in order to get the parser to
treat the final <code>tt</code> sequence as a particular kind of grammar construct.</p>
<p>Note that this specific set of macros is determined by what macros are allowed to expand to, <em>not</em>
what they are able to capture.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="counting"><a class="header" href="#counting">Counting</a></h1>
<h2 id="repetition-with-replacement"><a class="header" href="#repetition-with-replacement">Repetition with replacement</a></h2>
<p>Counting things in a macro is a surprisingly tricky task. The simplest way is to use replacement
with a repetition match.</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! replace_expr {
    ($_t:tt $sub:expr) =&gt; {$sub};
}

macro_rules! count_tts {
    ($($tts:tt)*) =&gt; {0usize $(+ replace_expr!($tts 1usize))*};
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    assert_eq!(count_tts!(0 1 2), 3);
</span><span class="boring">}
</span></code></pre></pre>
<p>This is a fine approach for smallish numbers, but will likely <em>crash the compiler</em> with inputs of
around 500 or so tokens. Consider that the output will look something like this:</p>
<pre><code class="language-rust ignore">0usize + 1usize + /* ~500 `+ 1usize`s */ + 1usize
</code></pre>
<p>The compiler must parse this into an AST, which will produce what is effectively a perfectly
unbalanced binary tree 500+ levels deep.</p>
<h2 id="recursion"><a class="header" href="#recursion">Recursion</a></h2>
<p>An older approach is to use recursion.</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! count_tts {
    () =&gt; {0usize};
    ($_head:tt $($tail:tt)*) =&gt; {1usize + count_tts!($($tail)*)};
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    assert_eq!(count_tts!(0 1 2), 3);
</span><span class="boring">}
</span></code></pre></pre>
<blockquote>
<p><strong>Note</strong>: As of <code>rustc</code> 1.2, the compiler has <em>grievous</em> performance problems when large numbers
of integer literals of unknown type must undergo inference. We are using explicitly
<code>usize</code>-typed literals here to avoid that.</p>
<p>If this is not suitable (such as when the type must be substitutable), you can help matters by
using <code>as</code> (<em>e.g.</em> <code>0 as $ty</code>, <code>1 as $ty</code>, <em>etc.</em>).</p>
</blockquote>
<p>This <em>works</em>, but will trivially exceed the recursion limit. Unlike the repetition approach, you can
extend the input size by matching multiple tokens at once.</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! count_tts {
    ($_a:tt $_b:tt $_c:tt $_d:tt $_e:tt
     $_f:tt $_g:tt $_h:tt $_i:tt $_j:tt
     $_k:tt $_l:tt $_m:tt $_n:tt $_o:tt
     $_p:tt $_q:tt $_r:tt $_s:tt $_t:tt
     $($tail:tt)*)
        =&gt; {20usize + count_tts!($($tail)*)};
    ($_a:tt $_b:tt $_c:tt $_d:tt $_e:tt
     $_f:tt $_g:tt $_h:tt $_i:tt $_j:tt
     $($tail:tt)*)
        =&gt; {10usize + count_tts!($($tail)*)};
    ($_a:tt $_b:tt $_c:tt $_d:tt $_e:tt
     $($tail:tt)*)
        =&gt; {5usize + count_tts!($($tail)*)};
    ($_a:tt
     $($tail:tt)*)
        =&gt; {1usize + count_tts!($($tail)*)};
    () =&gt; {0usize};
}

fn main() {
    assert_eq!(700, count_tts!(
        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,
        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,
        
        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,
        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,
        
        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,
        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,
        
        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,
        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,
        
        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,
        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,
        
        // Repetition breaks somewhere after this
        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,
        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,

        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,
        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,
    ));
}
</code></pre></pre>
<p>This particular formulation will work up to ~1,200 tokens.</p>
<h2 id="slice-length"><a class="header" href="#slice-length">Slice length</a></h2>
<p>A third approach is to help the compiler construct a shallow AST that won't lead to a stack overflow.
This can be done by constructing an array literal and calling the <code>len</code> method.</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! replace_expr {
    ($_t:tt $sub:expr) =&gt; {$sub};
}

macro_rules! count_tts {
    ($($tts:tt)*) =&gt; {&lt;[()]&gt;::len(&amp;[$(replace_expr!($tts ())),*])};
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    assert_eq!(count_tts!(0 1 2), 3);
</span><span class="boring">}
</span></code></pre></pre>
<p>This has been tested to work up to 10,000 tokens, and can probably go much higher.</p>
<h2 id="enum-counting"><a class="header" href="#enum-counting">Enum counting</a></h2>
<p>This approach can be used where you need to count a set of mutually distinct identifiers.</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! count_idents {
    ($($idents:ident),* $(,)*) =&gt; {
        {
            #[allow(dead_code, non_camel_case_types)]
            enum Idents { $($idents,)* __CountIdentsLast }
            const COUNT: u32 = Idents::__CountIdentsLast as u32;
            COUNT
        }
    };
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    const COUNT: u32 = count_idents!(A, B, C);
</span><span class="boring">    assert_eq!(COUNT, 3);
</span><span class="boring">}
</span></code></pre></pre>
<p>This method does have two drawbacks. First, as implied above, it can <em>only</em> count valid identifiers
(which are also not keywords), and it does not allow those identifiers to repeat.</p>
<p>Secondly, this approach is <em>not</em> hygienic, meaning that if whatever identifier you use in place of
<code>__CountIdentsLast</code> is provided as input, the macro will fail due to the duplicate variants in the
<code>enum</code>.</p>
<h2 id="bit-twiddling"><a class="header" href="#bit-twiddling">Bit twiddling</a></h2>
<p>Another recursive approach using bit operations: </p>
<pre><pre class="playground"><code class="language-rust">macro_rules! count_tts {
    () =&gt; { 0 };
    ($odd:tt $($a:tt $b:tt)*) =&gt; { (count_tts!($($a)*) &lt;&lt; 1) | 1 };
    ($($a:tt $even:tt)*) =&gt; { count_tts!($($a)*) &lt;&lt; 1 };
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    assert_eq!(count_tts!(0 1 2), 3);
</span><span class="boring">}
</span></code></pre></pre>
<p>This approach is pretty smart as it effectively halves its input whenever its even and then
multiplying the counter by 2 (or in this case shifting 1 bit to the left which is equivalent). If
the input is uneven it simply takes one token tree from the input <code>or</code>s the token tree to the
previous counter which is equivalent to adding 1 as the lowest bit has to be a 0 at this point due
to the previous shifting. Rinse and repeat until we hit the base rule <code>() =&gt; 0</code>.</p>
<p>The benefit of this is that the constructed AST expression that makes up the counter value will grow
with a complexity of <code>O(log(n))</code> instead of <code>O(n)</code> like the other approaches. Be aware that you can
still hit the recursion limit with this if you try hard enough. Credits for this method go to Reddit
user <a href="https://www.reddit.com/r/rust/comments/d3yag8/the_little_book_of_rust_macros/"><code>YatoRust</code></a>.</p>
<p>Let's go through the procedure by hand once:</p>
<pre><code class="language-rust ignore">count_tts!(0 0 0 0 0 0 0 0 0 0);
</code></pre>
<p>This invocation will match the third rule due to the fact that we have an even number of token trees
(10). The matcher names the odd token trees in the sequence <code>$a</code> and the even ones <code>$even</code> but the
expansion only makes use of <code>$a</code>, which means it effectively discards all the even elements cutting
the input in half. So the invocation now becomes:</p>
<pre><code class="language-rust ignore">count_tts!(0 0 0 0 0) &lt;&lt; 1;
</code></pre>
<p>This invocation will now match the second rule as its input is an uneven amount of token trees. In
this case the first token tree is discarded to make the input even again, then we also do the
halving step in this invocation again since we know the input would be even now anyways. Therefor we
can count 1 for the uneven discard and multiply by 2 again since we also halved.</p>
<pre><code class="language-rust ignore">((count_tts!(0 0) &lt;&lt; 1) | 1) &lt;&lt; 1;
</code></pre>
<pre><code class="language-rust ignore">((count_tts!(0) &lt;&lt; 1 &lt;&lt; 1) | 1) &lt;&lt; 1;
</code></pre>
<pre><code class="language-rust ignore">(((count_tts!() | 1) &lt;&lt; 1 &lt;&lt; 1) | 1) &lt;&lt; 1;
</code></pre>
<pre><code class="language-rust ignore">((((0 &lt;&lt; 1) | 1) &lt;&lt; 1 &lt;&lt; 1) | 1) &lt;&lt; 1;
</code></pre>
<p>Now to check if we expanded correctly manually we can use a one of the tools we introduced for
<a href="building-blocks//macros/minutiae/debugging.html"><code>debugging</code></a>. When expanding the macro there we should get:</p>
<pre><code class="language-rust ignore">((((0 &lt;&lt; 1) | 1) &lt;&lt; 1 &lt;&lt; 1) | 1) &lt;&lt; 1;
</code></pre>
<p>That's the same so we didn't make any mistakes, great!</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="abacus-counters"><a class="header" href="#abacus-counters">Abacus Counters</a></h1>
<blockquote>
<p><strong>Provisional</strong>: needs a more compelling example. Matching nested groups that are <em>not</em> denoted by
Rust groups is sufficiently unusual that it may not merit inclusion.</p>
</blockquote>
<blockquote>
<p><strong>Note</strong>: this section assumes understanding of <a href="building-blocks/abacus-counting.html#push-down-accumulation">push-down accumulation</a>
and <a href="building-blocks/abacus-counting.html#incremental-tt-munchers">incremental TT munchers</a>.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">macro_rules! abacus {
    ((- $($moves:tt)*) -&gt; (+ $($count:tt)*)) =&gt; {
        abacus!(($($moves)*) -&gt; ($($count)*))
    };
    ((- $($moves:tt)*) -&gt; ($($count:tt)*)) =&gt; {
        abacus!(($($moves)*) -&gt; (- $($count)*))
    };
    ((+ $($moves:tt)*) -&gt; (- $($count:tt)*)) =&gt; {
        abacus!(($($moves)*) -&gt; ($($count)*))
    };
    ((+ $($moves:tt)*) -&gt; ($($count:tt)*)) =&gt; {
        abacus!(($($moves)*) -&gt; (+ $($count)*))
    };

    // Check if the final result is zero.
    (() -&gt; ()) =&gt; { true };
    (() -&gt; ($($count:tt)+)) =&gt; { false };
}

fn main() {
    let equals_zero = abacus!((++-+-+++--++---++----+) -&gt; ());
    assert_eq!(equals_zero, true);
}
</code></pre></pre>
<p>This technique can be used in cases where you need to keep track of a varying counter that starts at
or near zero, and must support the following operations:</p>
<ul>
<li>Increment by one.</li>
<li>Decrement by one.</li>
<li>Compare to zero (or any other fixed, finite value).</li>
</ul>
<p>A value of <em>n</em> is represented by <em>n</em> instances of a specific token stored in a group. Modifications
are done using recursion and <a href="building-blocks/abacus-counting.html#push-down-accumulation">push-down accumulation</a>. Assuming the token
used is <code>x</code>, the operations above are implemented as follows:</p>
<ul>
<li>Increment by one: match <code>($($count:tt)*)</code>, substitute <code>(x $($count)*)</code>.</li>
<li>Decrement by one: match <code>(x $($count:tt)*)</code>, substitute <code>($($count)*)</code>.</li>
<li>Compare to zero: match <code>()</code>.</li>
<li>Compare to one: match <code>(x)</code>.</li>
<li>Compare to two: match <code>(x x)</code>.</li>
<li><em>(and so on...)</em></li>
</ul>
<p>In this way, operations on the counter are like flicking tokens back and forth like an abacus.<sup class="footnote-reference"><a href="#abacus">1</a></sup></p>
<div class="footnote-definition" id="abacus"><sup class="footnote-definition-label">1</sup>
<p>This desperately thin reasoning conceals the <em>real</em> reason for this name: to avoid having
<em>yet another</em> thing with &quot;token&quot; in the name. Talk to your writer about avoiding
<a href="https://en.wikipedia.org/wiki/Semantic_satiation">semantic satiation</a> today!<br />
In fairness, it could <em>also</em> have been called <a href="https://en.wikipedia.org/wiki/Unary_numeral_system">&quot;unary counting&quot;</a>.</p>
</div>
<p>In cases where you want to represent negative values, <em>-n</em> can be represented as <em>n</em> instances of a
<em>different</em> token. In the example given above, <em>+n</em> is stored as <em>n</em> <code>+</code> tokens, and <em>-m</em> is stored
as <em>m</em> <code>-</code> tokens.</p>
<p>In this case, the operations become slightly more complicated; increment and decrement effectively
reverse their usual meanings when the counter is negative. To which given <code>+</code> and <code>-</code> for the
positive and negative tokens respectively, the operations change to:</p>
<ul>
<li>Increment by one:
<ul>
<li>match <code>()</code>, substitute <code>(+)</code>.</li>
<li>match <code>(- $($count:tt)*)</code>, substitute <code>($($count)*)</code>.</li>
<li>match <code>($($count:tt)+)</code>, substitute <code>(+ $($count)+)</code>.</li>
</ul>
</li>
<li>Decrement by one:
<ul>
<li>match <code>()</code>, substitute <code>(-)</code>.</li>
<li>match <code>(+ $($count:tt)*)</code>, substitute <code>($($count)*)</code>.</li>
<li>match <code>($($count:tt)+)</code>, substitute <code>(- $($count)+)</code>.</li>
</ul>
</li>
<li>Compare to 0: match <code>()</code>.</li>
<li>Compare to +1: match <code>(+)</code>.</li>
<li>Compare to -1: match <code>(-)</code>.</li>
<li>Compare to +2: match <code>(++)</code>.</li>
<li>Compare to -2: match <code>(--)</code>.</li>
<li><em>(and so on...)</em></li>
</ul>
<p>Note that the example at the top combines some of the rules together (for example, it combines
increment on <code>()</code> and <code>($($count:tt)+)</code> into an increment on <code>($($count:tt)*)</code>).</p>
<p>If you want to extract the actual <em>value</em> of the counter, this can be done using a regular
<a href="building-blocks/./counting.html">counter macro</a>. For the example above, the terminal rules can be replaced with the following:</p>
<pre><code class="language-rust ignore">macro_rules! abacus {
    // ...

    // This extracts the counter as an integer expression.
    (() -&gt; ()) =&gt; {0};
    (() -&gt; (- $($count:tt)*)) =&gt; {
        - ( count_tts!($( $count_tts:tt )*) )
    };
    (() -&gt; (+ $($count:tt)*)) =&gt; {
        count_tts!($( $count_tts:tt )*)
    };
}

// One of the many token tree counting macros in the counting chapter
macro_rules! count_tts {
    // ...
}
</code></pre>
<blockquote>
<p><strong><abbr title="Just for this example">JFTE</abbr></strong>: strictly speaking, the above formulation of
<code>abacus!</code> is needlessly complex.  It can be implemented much more efficiently using repetition,
provided you <em>do not</em> need to match against the counter's value in a macro:</p>
<pre><code class="language-ignore">macro_rules! abacus {
    (-) =&gt; {-1};
    (+) =&gt; {1};
    ($( $moves:tt )*) =&gt; {
        0 $(+ abacus!($moves))*
    }
}
</code></pre>
</blockquote>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="parsing-rust"><a class="header" href="#parsing-rust">Parsing Rust</a></h1>
<p>Parsing some of Rust's items can be useful in certain situations. This section will show a few
macros that can parse some of Rust's more complex items like structs and functions to a certain extent.
The goal of these macros is not to be able to parse the entire grammar of the items but to parse
parts that are in general quite useful without being too complex to parse. This means we ignore
things like generics and such.</p>
<p>The main points of interest of these macros are their <code>matchers</code>. The transcribers are only there
for example purposes and are usually not that impressive.</p>
<h2 id="function"><a class="header" href="#function">Function</a></h2>
<pre><pre class="playground"><code class="language-rust">macro_rules! function_item_matcher {
    (

        $( #[$meta:meta] )*
    //  ^~~~attributes~~~~^
        $vis:vis fn $name:ident ( $( $arg_pat:ident : $arg_ty:ty ),* $(,)? )
    //                          ^~~~~~~~~~~~~~~~argument list~~~~~~~~~~~~~~~^
            $( -&gt; $ret_ty:ty )?
    //      ^~~~return type~~~^
            { $($tt:tt)* }
    //      ^~~~~body~~~~^
    ) =&gt; {
        $( #[$meta] )*
        $vis fn $name ( $( $arg_name : $arg_ty ),* ) $( -&gt; $ret_ty )? { $($tt)* }
    }
}

<span class="boring">function_item_matcher!(
</span><span class="boring">   #[inline]
</span><span class="boring">   #[cold]
</span><span class="boring">   pub fn foo(bar: i32, baz: i32, ) -&gt; String {
</span><span class="boring">       format!(&quot;{} {}&quot;, bar, baz)
</span><span class="boring">   }
</span><span class="boring">);
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    assert_eq!(foo(13, 37), &quot;13 37&quot;);
</span><span class="boring">}
</span></code></pre></pre>
<p>A simple function matcher that ignores qualifiers like <code>unsafe</code>, <code>async</code>, ... as well a generics and
where clauses. If parsing those is required it is likely that you are better off using a proc-macro
instead.</p>
<p>This lets you for example, inspect the function signature, generate some extra things from it and
then re-emit the entire function again. Kind of like a <code>Derive</code> proc-macro but weaker and for
functions.</p>
<blockquote>
<p>Ideally we would like to use a pattern fragment specifier instead of an ident for the arguments
but this is currently not allowed. Fortunately people don't use patterns in function signatures
that often so this is okay.</p>
</blockquote>
<h3 id="method"><a class="header" href="#method">Method</a></h3>
<p>The macro for parsing basic functions is nice and all, but sometimes we would like to also parse
methods, functions that refer to their object via some form of <code>self</code> usage. This makes things a bit
trickier:</p>
<blockquote>
<p>WIP</p>
</blockquote>
<h2 id="struct"><a class="header" href="#struct">Struct</a></h2>
<pre><pre class="playground"><code class="language-rust">macro_rules! struct_item_matcher {
    // Unit-Struct
    (
        $( #[$meta:meta] )*
    //  ^~~~attributes~~~~^
        $vis:vis struct $name:ident;
    ) =&gt; {
        $( #[$meta] )*
        $vis struct $name;
    };

    // Tuple-Struct
    (
        $( #[$meta:meta] )*
    //  ^~~~attributes~~~~^
        $vis:vis struct $name:ident (
            $(
                $( #[$field_meta:meta] )*
    //          ^~~~field attributes~~~~^
                $field_vis:vis $field_ty:ty
    //          ^~~~~~a single field~~~~~~^
            ),*
        $(,)? );
    ) =&gt; {
        $( #[$meta] )*
        $vis struct $name (
            $(
                $( #[$field_meta] )*
                $field_vis $field_ty
            ),*
        );
    };

    // Named-Struct
    (
        $( #[$meta:meta] )*
    //  ^~~~attributes~~~~^
        $vis:vis struct $name:ident {
            $(
                $( #[$field_meta:meta] )*
    //          ^~~~field attributes~~~!^
                $field_vis:vis $field_name:ident : $field_ty:ty
    //          ^~~~~~~~~~~~~~~~~a single field~~~~~~~~~~~~~~~^
            ),*
        $(,)? }
    ) =&gt; {
        $( #[$meta] )*
        $vis struct $name {
            $(
                $( #[$field_meta] )*
                $field_vis $field_name : $field_ty
            ),*
        }
    }
}

<span class="boring">struct_item_matcher!(
</span><span class="boring">   #[derive(Copy, Clone)]
</span><span class="boring">   pub(crate) struct Foo { 
</span><span class="boring">      pub bar: i32,
</span><span class="boring">      baz: &amp;'static str,
</span><span class="boring">      qux: f32
</span><span class="boring">   }
</span><span class="boring">);
</span><span class="boring">struct_item_matcher!(
</span><span class="boring">   #[derive(Copy, Clone)]
</span><span class="boring">   pub(crate) struct Bar;
</span><span class="boring">);
</span><span class="boring">struct_item_matcher!(
</span><span class="boring">   #[derive(Clone)]
</span><span class="boring">   pub(crate) struct Baz (i32, pub f32, String);
</span><span class="boring">);
</span><span class="boring">fn main() {
</span><span class="boring">   let _: Foo = Foo { bar: 42, baz: &quot;macros can be nice&quot;, qux: 3.14, };
</span><span class="boring">   let _: Bar = Bar;
</span><span class="boring">   let _: Baz = Baz(2, 0.1234, String::new());
</span><span class="boring">}
</span></code></pre></pre>
<h1 id="enum"><a class="header" href="#enum">Enum</a></h1>
<p>Parsing enums is a bit more complex than structs so we will finally make use of some of the
<a href="building-blocks//patterns.html">patterns</a> we have discussed, <a href="building-blocks//patterns/tt-muncher.html">Incremental TT Muncher</a> and <a href="building-blocks//patterns/internal-rules.html">Internal Rules</a>. Instead of just
building the parsed enum again we will merely visit all the tokens of the enum, as rebuilding the
enum would require us to collect all the parsed tokens temporarily again via a
<a href="building-blocks//patterns/push-down-acc.html">Push Down Accumulator</a>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! enum_item_matcher {
    // tuple variant
    (@variant $variant:ident (
        $(
            $( #[$field_meta:meta] )*
    //      ^~~~field attributes~~~~^
            $field_vis:vis $field_ty:ty
    //      ^~~~~~a single field~~~~~~^
        ),* $(,)?
    //âˆ¨~~rest of input~~âˆ¨
    ) $(, $($tt:tt)* )? ) =&gt; {
        
        // process rest of the enum
        $( enum_item_matcher!(@variant $( $tt )*) )?
    };
    // named variant
    (@variant $variant:ident {
        $(
            $( #[$field_meta:meta] )*
    //      ^~~~field attributes~~~!^
            $field_vis:vis $field_name:ident : $field_ty:ty
    //      ^~~~~~~~~~~~~~~~~a single field~~~~~~~~~~~~~~~^
        ),* $(,)?
    //âˆ¨~~rest of input~~âˆ¨
    } $(, $($tt:tt)* )? ) =&gt; {
        // process rest of the enum
        $( enum_item_matcher!(@variant $( $tt )*) )?
    };
    // unit variant
    (@variant $variant:ident $(, $($tt:tt)* )? ) =&gt; {
        // process rest of the enum
        $( enum_item_matcher!(@variant $( $tt )*) )?
    };
    // trailing comma
    (@variant ,) =&gt; {};
    // base case
    (@variant) =&gt; {};
    // entry point
    (
        $( #[$meta:meta] )*
        $vis:vis enum $name:ident {
            $($tt:tt)*
        }
    ) =&gt; {
        enum_item_matcher!(@variant $($tt)*)
    };
}

<span class="boring">enum_item_matcher!(
</span><span class="boring">   #[derive(Copy, Clone)]
</span><span class="boring">   pub(crate) enum Foo { 
</span><span class="boring">       Bar,
</span><span class="boring">       Baz,
</span><span class="boring">   }
</span><span class="boring">);
</span><span class="boring">enum_item_matcher!(
</span><span class="boring">   #[derive(Copy, Clone)]
</span><span class="boring">   pub(crate) enum Bar {
</span><span class="boring">       Foo(i32, f32),
</span><span class="boring">       Bar,
</span><span class="boring">       Baz(),
</span><span class="boring">   }
</span><span class="boring">);
</span><span class="boring">enum_item_matcher!(
</span><span class="boring">   #[derive(Clone)]
</span><span class="boring">   pub(crate) enum Baz {}
</span><span class="boring">);
</span><span class="boring">}
</span></code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        
        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
        
        

    </body>
</html>
